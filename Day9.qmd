---
format: 
  live-revealjs:
    theme: default
    scrollable: true
    auto-animate: true
    auto-animate-duration: 0.5
    auto-animate-easing: ease-in-out
    code-line-numbers: true
    css: reveal_style.css
    include-in-header:
      text: |
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
title: "MA-500 Intro to R"
engine: knitr
scrolling: FALSE
scrollable: FALSE
---

{{< include _extensions/r-wasm/live/_knitr.qmd >}}

{{< include ./_extensions/r-wasm/live/_gradethis.qmd >}}

------------------------------------------------------------------------

![](images/clipboard-126832707.jpeg)

------------------------------------------------------------------------

### Exploratory Data Analysis

EDA: **How should we visualize and transform your data in a systematic way?**

::: fragment
**1.** Generate questions about your data.
:::

::: fragment
**2.** Answer by visualizing, transforming, or modeling your data.
:::

::: fragment
**3.** Use what you learn to refine your question or generate new questions.
:::

------------------------------------------------------------------------

### `mtcars` dataset

`R` has a built-in dataset called `mtcars` (Motor Trend Car Road Tests) which you can pull directly.

```{r, echo=T}
# save it into our library
mtcars <- mtcars
print(head(mtcars))
```

------------------------------------------------------------------------

### Measures of Central Tendency

<medium>

::: fragment
We already know:

-   `mean()`

-   `median()`
:::

::: fragment
But, there is no `mode()` function. For that, we can use the `table()` function OR create our own `function`
:::

::: fragment
```{r, echo = TRUE}
table(mtcars$cyl)
```
:::

::: fragment
```{r, echo = TRUE}
mode <- function(x) {
  names(sort(-table(x)))[1]
}

mode(mtcars$cyl)
```
:::

</medium>

------------------------------------------------------------------------

### Variation

<medium> To see the variation in our data, we can use:

:::: fragment
::: incremental
-   `range()`
-   `var()`
-   `sd()`
-   `IQR()`
:::
::::

::: fragment
With these metrics, it is also great to visualize them:
:::

:::: fragment
::: callout-tip
If your variable is *continuous*, use a `histogram`. If your variable is *categorical*, use a `bar chart`.
:::
::::

</medium>

------------------------------------------------------------------------

### Visualizing Variation

::: {fragment}
```{r, echo = TRUE, eval = FALSE}
library(tidyverse)
ggplot(data = mtcars, aes(x=as.factor(cyl)))+
  geom_bar(aes(fill=as.factor(cyl)))+
  labs(x="Number of Cylinders", 
       fill = "Number of Cylinders")
```
:::

::: fragment
```{r}
library(tidyverse)
ggplot(data = mtcars, aes(x=as.factor(cyl)))+
  geom_bar(aes(fill=as.factor(cyl)))+
  labs(x="Number of Cylinders", 
       fill = "Number of Cylinders")
```
:::

------------------------------------------------------------------------

### Visualizing Variation

::: fragment
```{r, echo=TRUE, eval=FALSE}
ggplot(data=mtcars)+
  geom_histogram(aes(x=mpg), fill="lightblue", binwidth=0.5)
```
:::

::: fragment
```{r}
ggplot(data=mtcars)+
  geom_histogram(aes(x=mpg), fill="lightblue", binwidth=0.5)
```
:::

------------------------------------------------------------------------

### Visualizing Variation

::: fragment
```{r, eval = TRUE, echo = TRUE}
mtcars %>% 
  count(cut_width(mpg, 0.5))
```
:::

------------------------------------------------------------------------

### Unusual Values / Outliers

::: fragment
**Outliers** can significantly impact model fitting and statistical calculations. Always conduct exploratory analysis to understand your data (and know the context of your data!) These are
:::

:::: fragment
::: incremental
-   data points that don't seem to fit the pattern

-   sometimes data entry errors

-   sometimes real observations that suggest new information
:::
::::

------------------------------------------------------------------------

### Unusual Values / Outliers

::: fragment
```{r, echo = TRUE, eval = FALSE}
ggplot(data=mtcars, aes(x=hp))+
  geom_boxplot()
```
:::

::: fragment
```{r}
ggplot(data=mtcars, aes(x=hp))+
  geom_boxplot()
```
:::

------------------------------------------------------------------------

### Unusual Values / Outliers

::: fragment
But, let's make sure we consider outliers by groups too depending on your question.

```{r, echo = TRUE, eval = FALSE}
ggplot(data=mtcars, aes(x=hp))+
  geom_boxplot(aes(fill=as.factor(am)))
```
:::

::: fragment
```{r}
ggplot(data=mtcars, aes(x=hp))+
  geom_boxplot(aes(fill=as.factor(am)))
```
:::

------------------------------------------------------------------------

### Identifying outliers

::: fragment
-   Use boxplots/scatterplots/histograms

-   Filter data to observations \> Q3 + 1.5(IQR) or \< Q1 - 1.5(IQR)

```{r, echo = TRUE}
mtcars <- mtcars %>%
  mutate(
    Q1 = quantile(hp, 0.25),      # 25th percentile
    Q3 = quantile(hp, 0.75),      # 75th percentile
    IQR = Q3 - Q1,                 # Interquartile range
    lower_bound = Q1 - 1.5 * IQR,  # lower cutoff
    upper_bound = Q3 + 1.5 * IQR,  # upper cutoff
    outlier_iqr = ifelse(hp < lower_bound | hp > upper_bound, 1, 0)
  )

print(mtcars %>% filter(outlier_iqr == 1))
```
:::

------------------------------------------------------------------------

### Identifying outliers

::: fragment
-   or by the z-score method

```{r, echo = TRUE, eval = TRUE}
mtcars <- mtcars %>%
  mutate(zscore_hp = as.numeric(scale(hp)),
         outlier_zscore = ifelse(abs(zscore_hp) > 2, 1, 0))

print(mtcars %>% filter(outlier_zscore == 1))
```
:::

------------------------------------------------------------------------

### Identifying outliers

::: fragment
-   or by percentiles

```{r, echo = TRUE, eval = TRUE}
mtcars <- mtcars %>%
  mutate(
    outlier_pct = ifelse(hp > quantile(hp, 0.95), 1, 0)
  )

print(mtcars %>% filter(outlier_pct == 1))
```
:::

------------------------------------------------------------------------

### Handling outliers

<small>

::: incremental
1.  *Understand the Cause*:
    -   **Natural Variability**: Legitimate data variation
    -   **Data Entry Errors**: Mistakes in data collection or entry.
    -   **Instrument/Process Error**: Issues with data collection methods.
2.  *Decide on an Approach:*
    -   **Keep Them**: If they reflect true variation.
    -   **Transform Data**: Reduce their impact.
    -   **Cap/Floor Values**: Limit extreme outliers.
    -   **Remove Them**: If they’re errors or irrelevant—document decisions.
    -   **Use Robust Models**: Opt for models less sensitive to outliers.
3.  **ALWAYS DOCUMENT!**
:::

</small>

------------------------------------------------------------------------

### Covariance and Correlation

<small>

**Covariance** expresses how two numeric variables change together, whether it be positive or negative. (Covariance is sensitive and influenced by the units and scales of our variables.)

-   a positive result indicates a positive linear relationship - as *x* increases, *y* increases
-   a negative result indicates a negative linear relationship - as *x* decreases, *y* decreases

**Correlation** helps interpret covariance further by assessing both the strength and direction. The *Pearson's correlation coefficient*, $\rho_{xy}$, is the most commonly used measure, where $$-1 \leq \rho_{xy} \leq 1$$

-   $\rho_{xy} = -1$ indicates a near perfect negative linear relationship

-   $\rho_{xy} = 1$ indicates a near perfect positive linear relationship

-   However, the relationship gets weaker the closer the coefficient is to 0.

</small>

------------------------------------------------------------------------

### Covariance and Correlation

<medium>

:::::: columns
::::: column
Let's investigate more into the `mtcars` dataset and see if there is a relationship between `hp`, the gross horsepower of a car, and `qsec`, the shortest time taken to travel a quarter-mile distance.

::: fragment
```{r,echo = TRUE, eval = TRUE}
scatter <- ggplot(data = mtcars,
                  aes(x = hp, 
                      y = qsec))+
           geom_point()
```

```{r, echo = TRUE}
cov(mtcars$hp, mtcars$qsec)
cor(mtcars$hp, mtcars$qsec)
```
:::

::: column
```{r}
scatter
```
:::
:::::
::::::

</medium>

------------------------------------------------------------------------

### Effect of outliers

:::: callout-recall
::: small
In the `hp` variable, we had \~1–2 outliers (depending on your method of outliering).
:::
::::

```{r, eval = TRUE, echo = TRUE}
# outliers that are < or > IQR*1.5
head(mtcars %>% filter(outlier_iqr == 1))

# outliers that are > 95th percentile
head(mtcars %>% filter(outlier_pct == 1))
```

------------------------------------------------------------------------

### Effect of outliers

:::::: callout-example
What is the correlation between `hp` and `qsec` after we remove outliers?

::: fragment
```{r, eval = TRUE, echo = TRUE}
cor(mtcars$hp, mtcars$qsec)
```
:::

::: fragment
```{r, eval = TRUE, echo = TRUE}
cor(mtcars$hp[mtcars$outlier_iqr != 1], 
    mtcars$qsec[mtcars$outlier_iqr != 1])
```
:::

::: fragment
```{r, eval = TRUE, echo = TRUE}
cor(mtcars$hp[mtcars$outlier_pct != 1], 
    mtcars$qsec[mtcars$outlier_pct != 1])
```
:::
::::::

------------------------------------------------------------------------

### Covariance and Correlation

<medium>Let's quickly look at correlation using data from the `iris` data set. </medium> <small> This data set contains measurements of sepal width/length and petal length/width of 50 different flowers from 3 different species of iris. </small>

:::::: callout-example
::: fragment
What is the correlation between petal width and petal length?
:::

::: fragment
```{r, eval = TRUE, echo = TRUE}
cor(iris$Petal.Length, iris$Petal.Width)
```
:::

::: fragment
```{r, eval = TRUE, echo = TRUE}
ggplot(data = iris, aes(x=Petal.Length, y=Petal.Width))+
  geom_point()
```
:::
::::::

------------------------------------------------------------------------

### Covariance and Correlation

What happens when we observe the relationship by species?

::::: callout-example
::: fragment
```{r, echo = TRUE, eval = TRUE}
cor_group <- iris %>%
    group_by(Species) %>%
    summarize(correlation = cor(Petal.Length, Petal.Width))

print(cor_group)
```
:::

::: fragment
```{r, echo = TRUE, eval = TRUE}
ggplot(data = iris, aes(x=Petal.Length, y=Petal.Width))+
  geom_point()+facet_wrap(~Species)
```
:::
:::::

------------------------------------------------------------------------

### Covariance and Correlation

<medium> If you would like to compute the correlation of each numeric variable to eachother for the whole `mtcars` dataset: </medium>

::: fragment
```{r, echo = TRUE, eval = TRUE}
mtcars <- mtcars %>% select(mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb)
cor_matrix <- round(cor(mtcars),2)
cor_matrix
```
:::

------------------------------------------------------------------------

### Visualizing the Correlation Matrix

<medium>

:::::: callout-example
**Using ggplot2**

::: fragment
```{r, echo = TRUE, eval = TRUE}
cor_matrix <- as.data.frame(cor_matrix)
cor_matrix$var1 <- row.names(cor_matrix)
head(cor_matrix, 3)
```
:::

::: fragment
```{r, echo = TRUE, eval = TRUE}
cor_matrix <- pivot_longer(cor_matrix, 
                           cols = colnames(mtcars), 
                           names_to = "var2")
cor_matrix$var1 <- factor(cor_matrix$var1, 
                          levels = rev(colnames(mtcars)))
cor_matrix$var2 <- factor(cor_matrix$var2, 
                          levels = colnames(mtcars))
```
:::

::: fragment
```{r, echo = TRUE, eval = TRUE}
# create a correlation matrix heatmap 
heatmap <- ggplot(cor_matrix, aes(x = var1, 
                                  y = var2, 
                                  fill = value))+
  geom_tile()+
  scale_fill_gradient2(
    low = "darkblue",  
    mid = "white",     
    high = "red",      
    midpoint = 0,      
    limits = c(-1, 1))  

print(heatmap)
```
:::
::::::

</medium>

------------------------------------------------------------------------

### Visualizing the correlation matrix

<medium>

:::: callout-example
**Using \``corrplot`**

::: fragment
```{r, echo = TRUE, eval = TRUE}
library(corrplot)
cor_mat <- cor(mtcars)
corrplot(cor_mat)
```
:::
::::

</medium>

------------------------------------------------------------------------

### Data Transformations

::: small
T*ransforming data*, not cleaning, re-arranging, or fixing typos, but taking the **log** or the **square root** to help make patterns easier to see and analyze or scale the data better.
:::

:::: fragment
::: small
**Why transform?**

-   reduce skewness (make more normal?)
-   stabilize the spread
-   linearize the non-linear
-   reduce the impact of outliers
:::
::::

------------------------------------------------------------------------

### Data Transformations

::: small
Let's look at the `diamonds` (prices of over 50,000 round cut diamonds) data set! (This comes with `ggplot2`).
:::

::: fragment
```{r, echo = TRUE, eval = TRUE}
hist(diamonds$price, col = "blue")
```
:::

::: fragment
```{r, echo = TRUE, eval = TRUE}
hist(log(diamonds$price), col="blue")
```
:::

```{r, echo = TRUE}
hist(sqrt(diamonds$price), col="blue")
```

------------------------------------------------------------------------

### Data Transformation

::: fragment
```{r, echo = TRUE, eval = TRUE}
ggplot(diamonds, aes(x = carat, y = price)) +
  geom_point() +
  labs(title = "Carat vs Price (Raw)")

```
:::

------------------------------------------------------------------------

### Data Transformation

::: fragment
```{r, echo = TRUE, eval = TRUE}
ggplot(diamonds, aes(x = log(carat), y = log(price))) +
  geom_point(alpha = 0.3, col = "blue") +
  labs(title = "Carat vs Price (Log)")
```
:::

------------------------------------------------------------------------

### Model Impacts

::: small
Correlation measures the **linear** relationship/association between two variables.
:::

::: fragment
```{r, eval = TRUE, echo = TRUE}
cor(diamonds$carat, diamonds$price)
```
:::

::: fragment
```{r, eval = TRUE, echo = TRUE}
cor(log(diamonds$carat), log(diamonds$price))
```
:::

:::: fragment
::: small
Transforming to **log** will help when relationship is curved or skewed, especially when driven by outliers.
:::
::::

:::::: fragment
::::: columns
::: column
```{r}
ggplot(diamonds, aes(x = carat, y = price)) +
  geom_point() +
  labs(title = "Carat vs Price (Raw)")
```
:::

::: column
```{r}
ggplot(diamonds, aes(x = log(carat), y = log(price))) +
  geom_point(alpha = 0.3, col = "blue") +
  labs(title = "Carat vs Price (Log)")
```
:::
:::::
::::::

------------------------------------------------------------------------

### Model Impacts

```{r}
pretty_lm <- function(model) {
  s <- summary(model)
  cat("Model Formula:", deparse(formula(model)), "\n\n")
  cat("R-squared:", round(s$r.squared, 3), "\n")
  cat("Adj R-squared:", round(s$adj.r.squared, 3), "\n")
  cat("Residual Std Error:", round(s$sigma, 3), "\n\n")
  print(coef(s))
}

```

::::::: columns
:::: column
```{r, echo = TRUE, eval = FALSE}
summary(lm(price ~ carat, 
           data = diamonds))
```

::: small
```{r}
pretty_lm(lm(price ~ carat,
             data = diamonds))
```
:::
::::

:::: column
```{r, echo = TRUE, eval = FALSE}
summary(lm(log(price) ~ log(carat), 
           data = diamonds))
```

::: small
```{r}
pretty_lm(lm(log(price) ~ log(carat), 
          data = diamonds))
```
:::
::::
:::::::

------------------------------------------------------------------------

### COVID-19 data set

Your group assignment will be focused on data cleaning from a data set from the Guam Department of Public Health. This data set contains information about COVID-19 cases with specific demographic information such as: ethnicity, village, sex, case status, etc.

::: fragment
**Your task**: Clean the variables `ethnicity`, `village`, and `case_identification: How.was.case.identified?`.
:::

::: fragment
**Ethnicity**

We want all ethnicities to be grouped into:

-   Chamorro
-   Filipino
-   White
-   Chuukese
-   other Pacific Islander
-   other Asian
-   Mixed
:::

::: fragment
**Village**

For villages, this will be by:

-   all main Guam Villages

-   OOJ (our of jurisdiction)
:::

<div>

**Case Identifications**

-   Clinical Evaluation

-   Routine surveillance

-   Contact Tracing

</div>

------------------------------------------------------------------------

### String Manipulation

:::: medium
Often times, we come across *messy* or *inconsistent* data. This can be due to a number of potential reasons, but more often than not, it is due to lack of data validations, user-entry errors, etc. In order to formally analyze the data. it is imperative that the data be cleaned or put into a standard form.

::: fragment
To clean string data, we will be using the `stringr` package (which comes with `tidyverse`)
:::
::::

------------------------------------------------------------------------

### `stringr` functions - subsetting

:::::::: medium
```{r}
#| echo: true
#| eval: false
#| code-line-numbers: "1|2|"
x <- c("stats", "statistics", "math")
str_sub(x, 1, 4)
```

::: fragment
```{r}
x <- c("stats", "statistics", "math")
str_sub(x, 1, 4)
```
:::

::: fragment
```{r}
#| echo: true
#| eval: false
#| code-line-numbers: "1|3-6"

df <- data.frame(flight = c("UA1234", "DL845", "AA99"))

df <- df %>% mutate(
  airline = str_sub(flight, 1,2),
  flight_num = str_sub(flight, 3)
)

print(df)
```
:::

::: fragment
```{r}
df <- data.frame(flight = c("UA1234", "DL845", "AA99"))

df <- df %>% mutate(
  airline = str_sub(flight, 1,2),
  flight_num = str_sub(flight, 3)
)

print(df)
```
:::

:::: fragment
::: callout-tip
You can also use **negative values** to count backwards from the end of the string.

```{r, echo = TRUE}
# neg1 is the last character
str_sub(x, -3, -1)
```
:::
::::
::::::::

------------------------------------------------------------------------

### `stringr` functions - detecting string matches

::::::::: mediumL
```{r}
#| echo: true
#| eval: false
#| code-line-numbers: "1|2|"
x <- c("stats", "statistics", "math")
str_detect(x, "stat")
```

::: fragment
```{r}
x <- c("stats", "statistics", "math")
str_detect(x, "stat")
```
:::

::::::: fragment
```{r}
#| echo: true
#| eval: false
#| code-line-numbers: "1|3-4|"

class <- c("MA500", "MA541","MATH")

# detect if numbers exist in string
str_detect(class, "[0-9]+")
```

::: fragment
```{r}
class <- c("MA500", "MA541","MATH")

# detect if numbers exist in string
str_detect(class, "[0-9]+")
```
:::

::::: fragment
`str_detect` returns BOOLEAN variables, so it is helpful to use when we are filtering. For example:

::: fragment
```{r}
#| echo: true
#| eval: false

df %>% 
  filter(str_detect(flight, "UA"))
```
:::

::: fragment
```{r}
df %>% 
  filter(str_detect(flight, "UA"))
```
:::
:::::
:::::::
:::::::::

------------------------------------------------------------------------

### Regex Basics - Regular Expressions

:::: medium
**What is regex?**

-   concise language for describing patterns in strings

::: fragment
| Pattern | Description |
|----|----|
| `[0-9]` or `\\d` | any digit from 0 - 9 |
| `[A-Z]` | any UPPERCASE letter from A - Z |
| `[a-z]` | any LOWERCASE letter from A - Z |
| `+` | one or more *(usually used in combination of above patterns)* |
| `?` | zero or more |
| `*` | zero or more |
| `^` | start of string |
| `$` | end of string |
| `.` | every character except a new line |
:::
::::

------------------------------------------------------------------------

### back to `str_detect` quickly

:::::: mediumL
```{r}
#| echo: true
#| eval: false

df %>% 
  filter(str_detect(flight, "^UA"))
```

::: fragment
```{r}
df %>% 
  filter(str_detect(flight, "^UA"))
```
:::

:::: fragment
```{r}
#| echo: true
#| eval: false
#| code-line-numbers: "1|2|3"
hobbies <- c("cooking", "reading", "eating", "dance", "sport")
str_detect(hobbies, "ing$")
```

::: fragment
```{r}
hobbies <- c("cooking", "reading", "eating", "dance", "sport")
str_detect(hobbies, "ing$")
```
:::
::::
::::::

------------------------------------------------------------------------

### `stringr` functions - detecting string matches

:::: medium
We can also use the functions `str_starts` or `str_ends` to detect patterns in the beginning or end of strings.

::: fragment
```{r}
#| echo: true
#| eval: true

hobbies <- c("cooking", "reading", "eating", "dance", "sport")
str_starts(hobbies, "cook")

str_ends(hobbies, "ing")

```
:::
::::

------------------------------------------------------------------------

### `stringr` functions - mutating string matches

::::::::: medium
We can use `str_sub` to also change the content of the data.

::: fragment
```{r}
#| echo: true
#| eval: false
#| code-line-numbers: "1|2|3|1-3"
hobbies <- c("cooking", "reading", "eating")
str_sub(hobbies, -3, -1) <- ""
print(hobbies)
```
:::

::: fragment
```{r}
hobbies <- c("cooking", "reading", "eating")
str_sub(hobbies, -3, -1) <- ""
print(hobbies)
```
:::

::: fragment
Let's try the same process but using `str_replace` instead
:::

::: fragment
```{r}
#| echo: true
#| eval: true
#| code-line-numbers: "1|2|3|1-6"
hobbies <- c("cooking", "reading", "eating")
str_replace(hobbies, "ing", "")
print(hobbies)

hobbies <- str_replace(hobbies, "ing", "")
print(hobbies)
```
:::

:::: fragment
::: callout-note
`str_replace` only replaces the **first** instance or the first matched pattern in each string - if you want to replace **all** instances, use `str_replace_all`
:::
::::
:::::::::

------------------------------------------------------------------------

### Combing string detection with operators

:::::::::::::::: medium
::: small
We can look for multiple patterns at once. For example,
:::

::: fragment
```{r}
#| echo: true
#| eval: true
x <- c("MA500", "BA124", "MA354", "PY100")
str_detect(x, "MA|PY")
```
:::

:::: fragment
::: small
Let's detect string variables that match only Males.
:::

```{r}
#| echo: true
#| eval: true

gender <- c("math", "MALE", "m", "female", "Male", "Female", "Male1")
str_detect(gender, "m")
```
::::

:::: fragment
::: small
Notice, the second element returns `FALSE` but we expect it to be true. That is because our string detection is **case-sensitive.** Good practice is to first bring everything to lower case using the function `str_to_lower`.
:::
::::

::: fragment
```{r}
#| echo: true
#| eval: true

gender <- c("math", "MALE", "m", "female", "Male", "Female", "Male1")
str_detect(str_to_lower(gender), "m")
```
:::

:::: fragment
::: small
Now, we see everything returns `TRUE` when we expect the Female strings to be `FALSE`. That is because providing `str_detect` with only `m` will just check if the variable contains `m`.
:::
::::

::: fragment
```{r}
#| echo: true
#| eval: true

gender <- c("math", "MALE", "m", "female", "Male", "Female", "Male1")
str_detect(str_to_lower(gender), "^m")
```
:::

:::: fragment
::: small
We added in `^` to indicate the string should start with `m`, but it also returns `TRUE` for the first element. Let's fix this up one more time.
:::
::::

::: fragment
```{r}
#| echo: true
#| eval: true

gender <- c("math", "MALE", "m", "female", "Male", "Female", "Male1", "Male1234")
#str_detect(str_to_lower(gender), "^^(mal)|^(male)$")
str_detect(str_to_lower(gender), "^(m|male)$|(male.+)")
```
:::
::::::::::::::::

------------------------------------------------------------------------

### Re-categorizing in a data set {auto-animate="true"}

::: medium
Let's say we want to clean the gender vector by standardizing its values — replacing each messy or inconsistent entry with a consistent label (e.g., ‘Male’ or ‘Female’). For this, we will use `case_when()` which is like an `ifelse` statement but easier to implement with many cases.
:::

------------------------------------------------------------------------

### Re-categorizing in a data set {auto-animate="true"}

::: {data-id = "case"}

```{r}
#| echo: true
#| eval: false

gen_df <- data.frame(gender = c(
  "M", "male", "FEMALE", "f", "Fem", "maLe", 
  "Feemale", "fem.", "MALE", "m.", "femail", 
  "Unknown", "?", "u", "U.", "N/A", "none", "", 
  "Other","prefer_not", 
  "MALE", "femAle", "Prefers not", "Othr", "na"
))
```

:::

------------------------------------------------------------------------

### Re-categorizing in a data set {auto-animate="true"}

::: {data-id = "case"}

```{r}
#| echo: true
#| eval: false

gen_df <- data.frame(gender = c(
  "M", "male", "FEMALE", "f", "Fem", "maLe", 
  "Feemale", "fem.", "MALE", "m.", "femail", 
  "Unknown", "?", "u", "U.", "N/A", "none", "", 
  "Other","prefer_not", 
  "MALE", "femAle", "Prefers not", "Othr", "na"
))

gen_df <- gen_df %>% 
  mutate(gender_clean = case_when(
    
  ))
```

:::

------------------------------------------------------------------------

### Re-categorizing in a data set {auto-animate="true"}

::: {data-id = "case"}

```{r}
#| echo: true
#| eval: false

gen_df <- data.frame(gender = c(
  "M", "male", "FEMALE", "f", "Fem", "maLe", 
  "Feemale", "fem.", "MALE", "m.", "femail", 
  "Unknown", "?", "u", "U.", "N/A", "none", "", 
  "Other","prefer_not", 
  "MALE", "femAle", "Prefers not", "Othr", "na"
))

gen_df <- gen_df %>% 
  mutate(gender_clean = case_when(
    str_detect(str_to_lower(gender), "^(m)|^(male)$")
  ))
```

:::

------------------------------------------------------------------------

### Re-categorizing in a data set {auto-animate="true"}

::: {data-id = "case"}

```{r}
#| echo: true
#| eval: false

gen_df <- data.frame(gender = c(
  "M", "male", "FEMALE", "f", "Fem", "maLe", 
  "Feemale", "fem.", "MALE", "m.", "femail", 
  "Unknown", "?", "u", "U.", "N/A", "none", "", 
  "Other","prefer_not", 
  "MALE", "femAle", "Prefers not", "Othr", "na"
))

gen_df <- gen_df %>% 
  mutate(gender_clean = case_when(
    str_detect(str_to_lower(gender), "^(m)|^(male)$") ~ "Male"
  ))
```

:::

```{r}
gen_df <- data.frame(gender = c(
  "M", "male", "FEMALE", "f", "Fem", "maLe", 
  "Feemale", "fem.", "MALE", "m.", "femail", 
  "Unknown", "?", "u", "U.", "N/A", "none", "", 
  "Other","prefer_not", 
  "MALE", "femAle", "Prefers not", "Othr", "na"
))

gen_df <- gen_df %>% 
  mutate(gender_clean = case_when(
    str_detect(str_to_lower(gender), "^(m)|^(male)$") ~ "Male"
  ))

print(gen_df)
```

------------------------------------------------------------------------

### Re-categorizing in a data set {auto-animate="true"}

::: {data-id = "case"}

```{r}
#| echo: true
#| eval: false

gen_df <- data.frame(gender = c(
  "M", "male", "FEMALE", "f", "Fem", "maLe", 
  "Feemale", "fem.", "MALE", "m.", "femail", 
  "Unknown", "?", "u", "U.", "N/A", "none", "", 
  "Other","prefer_not", 
  "MALE", "femAle", "Prefers not", "Othr", "na"
))

gen_df <- gen_df %>% 
  mutate(gender_clean = case_when(
    str_detect(str_to_lower(gender), "^(m)|^(male)$") ~ "Male", 
    str_detect(str_to_lower(gender), "^(f|female)$|(^fem)|(^fe+m)") ~ "Female"
  ))
```

:::

------------------------------------------------------------------------

### Re-categorizing in a data set {auto-animate="true"}

::: {data-id = "case"}

```{r}
#| echo: true
#| eval: false

gen_df <- data.frame(gender = c(
  "M", "male", "FEMALE", "f", "Fem", "maLe", 
  "Feemale", "fem.", "MALE", "m", "femail", 
  "Unknown", "?", "u", "U.", "N/A", "none", "", 
  "Other","prefer_not", 
  "MALE", "femAle", "Prefers not", "Othr", "na"
))

gen_df <- gen_df %>% 
  mutate(gender_clean = case_when(
    str_detect(str_to_lower(gender), "^(m)|^(male)$") ~ "Male", 
    str_detect(str_to_lower(gender), "^(f|female)$|(^fem)|(^fe+m)") ~ "Female"
  ), 
  gender_clean = ifelse(is.na(gender_clean), "Unknown", gender_clean)
  )
```

:::

```{r}
gen_df <- data.frame(gender = c(
  "M", "male", "FEMALE", "f", "Fem", "maLe", 
  "Feemale", "fem.", "MALE", "m", "femail", 
  "Unknown", "?", "u", "U.", "N/A", "none", "", 
  "Other","prefer_not", 
  "MALE", "femAle", "Prefers not", "Othr", "na"
))

gen_df <- gen_df %>% 
  mutate(gender_clean = case_when(
    str_detect(str_to_lower(gender), "^(m)|^(male)$") ~ "Male", 
    str_detect(str_to_lower(gender), "^(f|female)$|(^fem)|(^fe+m)") ~ "Female"
  ), 
  gender_clean = ifelse(is.na(gender_clean), "Unknown", gender_clean)
  )

print(gen_df)
```

------------------------------------------------------------------------

## Re-categorizing in a data set

::::::::: medium
Let's break down the female regex a bit further.

```{r, echo = TRUE, eval = FALSE}
str_detect(str_to_lower(gender), "^(f|female)$|(^fem)|(^fe+m)") ~ "Female"
```

::: fragment
```{r, echo = TRUE, eval = TRUE}
just_female <- gen_df$gender[gen_df$gender_clean == "Female"]
print(just_female)
```
:::

:::: fragment
::: small
We know that `^f` means if the string STARTS with f (use with caution because this will capture everything that starts with f), and `female$` essentially just captures the appropriate string we would like. But,

`"^(f|female)$|(^fem)|(^fe+m)"` -\> what is this??
:::
::::

::: fragment
```{r, echo = TRUE}
# if we set up our pattern the same way we set up the male example previously, we get:
str_detect(str_to_lower(just_female), "^(f|female)$")
```

We need to capture: `Fem`, `Feemale`, `fem.`, and `femail` as well.

-   Things I recognized:

    -   All of these started with `fem` , so : `^fem`
:::

::: fragment
```{r, echo = TRUE}
str_detect(str_to_lower(just_female), "^(f|female)$|(^fem)")
```

However, we are still not capturing `Feemale` .
:::

::: fragment
We will add in another condition

-   `^fe+m`
-   This states that the letter `e` can appear one or more times

```{r, echo = TRUE}
str_detect(str_to_lower(just_female), "^(f|female)$|(^fem)|(^fe+m)")
```
:::
:::::::::

# Conditionals, Loops, and Functions {.unnumbered}

When you need to control the flow and logic of your code, you can use conditional statements, loops, or functions.

-   **Conditionals (e.g., `if`, `else if`, `else`)** let you run certain sections of code only if a specific condition is true. This is useful when you want your program to make decisions or take different paths depending on the situation.

-   **Functions** let you **group code into reusable blocks**. Instead of repeating the same code in multiple places, you can define it once and call it whenever you need. Functions can also take inputs (arguments) and return outputs (results).

-   **Loops (e.g., `for`, `while`)** allow you to repeat sections of code multiple times without writing them out again. This is especially helpful when performing the same task on many items, such as processing each value in a dataset. (*Note: we won't be going over the while loop in this class)*

## Templates

### If-Else

```{r if_else, eval = FALSE}
if (condition) {
 do something
} else if (condition2) {
 do something
} else {
do this instead
}
```

### Functions

```{r functions, eval = FALSE}

#' purpose of this function
#'
#' @param arg1 define arg1
#' @param arg2 define arg2
#'
#' @return description 
function_name <- function(arg1, arg2, ...) {
  
  # do something here with arg1 and arg2
  
  # Step 3: Return the result
  return(result)
}


# Call (use) the function
function_name(value1, value2)

```

### Loops

```{r loop, eval = FALSE}
for (loopindex in vector) {
  do this
}
```

## If-else

::: callout-example
Write an `if-else` statement that prints the letter grade based off of the numeric scores.

-   **A**: `90` or higher
-   **B**: `75`-`89`
-   **C**: less than `75`

*Solution:*

```{r}
score <- 80

if (score >= 90) {
  print("A") 
} else if (score >= 75) {
  print("B")
} else {
  print("C")
}
```
:::

## Functions

Let us extend our `if-else` statement from above and put it into a defined function that takes the numeric score as an input and outputs its respective letter grade.

::: callout-example
Write a function that assigns the letter grade based off of the numeric scores.

-   **A**: `90` or higher
-   **B**: `75`-`89`
-   **C**: less than `75`

*Solution:*

```{r}
#' This function returns a letter grade based off of their numeric grade.
#' 
#' param @score numeric score from 0-100
#' return A,B,C
get_grade <- function(score) {
  if (score >= 90) {
  grade <- "A"
} else if (score >= 75) {
  grade <- "B"
} else {
  grade <- "C"
}
  return(grade)
}

# call the function
get_grade(80)
get_grade(100)
get_grade(8)
```
:::

### Recursive Functions

A `recursive function` is a function that calls itself to solve smaller instances of the same problem. It’s particularly useful for tasks that can be broken down into simpler, repetitive sub-tasks.

::: callout-example
Calculate the `factorial` of a non-negative integer n,

$$n! = n \times (n - 1) \times (n - 2) \times . . . \times 2 \times 1 $$

*Solution:*

```{r}
#' Calculate the factorial of a given integer using recursion
#'
#' @param n non-negative integer
#' @return n!
factorial_recursive <- function(n) {
 if(n == 0) {
  return(1)
 } else {
  return(n * factorial_recursive(n-1))
 }
}

factorial_recursive(6)
```
:::

Note: `R` already has a base function called `factorial`.

## Case Study: GovGuam Tax Revenue

Let’s examine the table showing Government of Guam tax revenue from 2017-2022 from the [2023 Guam Statistical Yearbook](https://bsp.guam.gov/wp-bsp-content/uploads/2025/01/2023-Guam-Statistical-Yearbook-Final.pdf).

![](images/clipboard-3553642164.png){width="1200"}

::: callout-case_study
***To-dos:*****\***

-   Make two separate vectors: one for the dollar amounts in each category (excluding the total) for 2022, and another for 2021.

-   Add attributes to each vector that describe what the values represent (the category or description).

-   Find the difference in tax revenue between 2021 and 2022 in each category.

-   Build two vectors that calculate what percent of the total revenue comes from each category for 2022 and 2021.

-   Write a function that takes in a percentage value (e.g., the share of a tax category) and classifies it into these categories:

    -   `> 30%` : Large Share
    -   `> 10%` : Medium Share
    -   `< 10%` : Small Share

-   Use a for loop to categorize each value in our vectors.
:::

1.  Make two separate vectors: one for the dollar amounts in each category (excluding the total) for 2022, and another for 2021.

```{r}
# 2021 tax rev values
tr_21 <- c(352818, 296806, 65110, 35612, 12372, 10100, 34978, 3519, 3761, 1395, 0)

# 2022 tax rev values
tr_22 <- c(372492, 327115, 76141, 35794, 18169, 9353, 31643, 4953, 3562, 1473, 0)
```

2.  Add attributes to each vector that describe what the values represent (the category or description).

```{r}
categories <- c("Income", "Gross Receipts", "Section 30 Federal income tax", "Property", "Hotel Occupancy", "Liquid Fuel", "Tabacco", "Alcoholic Beverages", "Excise", "Lmited Gaming", "Other")

names(tr_21) <- categories
names(tr_22) <- categories

## -- OR

tr_21 <- c("Income" = 352818, "Gross Receipts" = 296806, "Section 30 Federal income tax" = 65110, 
           "Property" = 35612, "Hotel Occupancy" = 12372, "Liquid Fuel" = 10100, "Tabacco" = 34978, 
           "Alcoholic Beverages" = 3519, "Excise" = 3761, "Lmited Gaming" = 1395, "Other" = 0)

tr_22 <- c("Income" = 372492, "Gross Receipts" = 327115, "Section 30 Federal income tax" = 76141, 
           "Property" = 35794, "Hotel Occupancy" = 18169, "Liquid Fuel" = 9353, "Tabacco" = 31643, 
           "Alcoholic Beverages" = 4953, "Excise" = 3562, "Lmited Gaming" = 1473, "Other" = 0)

```

3.  Find the difference in tax revenue between 2021 and 2022 in each category.

```{r}
diff_taxRev <- tr_22 - tr_21
```

4.  Build two vectors that calculate what percent of the total revenue comes from each category for 2022 and 2021.

```{r}
# grab the total number of tax revenue from all categories for both years
total_22 <- sum(tr_22)
total_21 <- sum(tr_21)

# divide each category by total and multiply by 100 to get percent
pct_tr_21 <- tr_21/total_21 * 100
pct_tr_22 <- tr_22/total_22 * 100
```

5.  Write a function that takes in a percentage value and classifies it into these categories: `>30%`: Large Share, `>10%`: Medium Share, `<10%`: Small Share

```{r}

#' This function groups the share sizes based off of a percentage value.
#' 
#'@param percent_val a percentage value representing tax revenue
#'@return string of either "Large", "Medium", "Small Share"
categorize_tax <- function(percent_val) {
  if (percent_val > 30) {
    share <- "Large Share"
  } else if (percent_val > 10) {
    share <- "Medium Share"
  } else {
    share <- "Small Share"
  }
  return(share)
}

# test each possible case
categorize_tax(40)
categorize_tax(12)
categorize_tax(9)
```

5.  Use a for loop to categorize each value in our vectors. Check how many of each share we have.

```{r}
share_categories <- c()
for (pct in pct_tr_21) {
  share_categories <- append(share_categories, categorize_tax(pct))
  
}

```

## Lists vs. Vectors

A ***vector*** is a one dimensional array of elements that must be the SAME type. Almost all data in `R` is stored in a vector.

A ***list*** **is a recursive vector**, meaning a list can contain multiple vectors or other lists. Lists can contain lists of vectors or lists of dataframes. Lists can contain any data-type.

::: callout-example
Create/Define a list.

*Solution:*

```{r}

# vector num: numeric
num <- c(1,8,9,2)

# vector char: character 
char <- c("Apple", "Banana")

# list: l combination of num and char
l <- list(num, char)
print(l)
```
:::

::: callout-example
Indexing a list:

```{r}

# returns the first element of the list 
# single bracket - returns as a list
print(l[1])

# double bracker - returns back the vector
print(l[[1]])

# returns the second element of the list
print(l[2])
print(l[[2]])

# returns the 3rd element of the vector in the first element of the list
print(l[[1]][3])


# setting names in the list
names(l) <- c("num", "char")

# indexing using names
print(l$num[3])
```
:::

### The `apply()` family

The `apply()` family are several functions in R that provide a way to apply functions across different data structures without the need to write explicit loops. These functions allow you to work more efficiently with vectors, lists, dataframes, and in a much cleaner way.

+------------+---------------+------------+--------------------------------------------------------------------------+
| Function   | Input         | Output     | Description                                                              |
+============+===============+============+==========================================================================+
| `apply()`  | -   Matrix    | -   Vector | Applies a specified function across rows or columns                      |
|            |               |            |                                                                          |
|            | -   Dataframe | -   Array  |                                                                          |
+------------+---------------+------------+--------------------------------------------------------------------------+
| `lapply()` | -   List      | -   List   | Applies a function to each element; always returns a list                |
|            |               |            |                                                                          |
|            | -   Vector    |            |                                                                          |
+------------+---------------+------------+--------------------------------------------------------------------------+
| `sapply()` | -   List      | -   Vector | same as `sapply()` but returns the most simplified version it can return |
|            |               |            |                                                                          |
|            | <!-- -->      | -   Matrix |                                                                          |
|            |               |            |                                                                          |
|            | -   Vector    | -   List   |                                                                          |
+------------+---------------+------------+--------------------------------------------------------------------------+

Let's use some of the functions above to categorize our tax revenue percentage vectors with the above `share_categories()` function.

```{r}
categories <- lapply(pct_tr_21, categorize_tax)
print(categories)
class(categories)
```

```{r}
categories_sapply <- sapply(pct_tr_21, categorize_tax)
print(categories_sapply)
class(categories_sapply)
```

## Vectorized Functions

Most base `R` functions are *vectorized,* meaning they automatically apply the function or operation to every element in a vector provided.

Our function `categorize_tax` is NOT vectorized. You can see below that we can an error if we try to input the ENTIRE percent vector into the function.

::: callout-caution
```{r}
categorize_tax(pct_tr_21)
```
:::

To make our `categorize_tax` function vectorized, we need to adjust the code. Rather than using nested `if-else` statements, we can use `ifelse()`, which is the vectorized version and works element-wise across an entire vector.

::: callout-example
#### Non-Vectorized Function vs Vectorized Function

*Before vectorizing: (we need to run a loop using this function to do element-wise operations on it)*

```{r}
#' This function groups the share sizes based off of a percentage value.
#' 
#'@param percent_val a percentage value representing tax revenue
#'@return string of either "Large", "Medium", "Small Share"
categorize_tax <- function(percent_val) {
  if (percent_val > 30) {
    share <- "Large Share"
  } else if (percent_val > 10) {
    share <- "Medium Share"
  } else {
    share <- "Small Share"
  }
  return(share)
}
```

*After vectoring: we can directly provide this function our vector and it will automatically perform element wise operations on it because the inner `ifelse()`* *is a vectorized function.*

```{r}
#' This function groups the share sizes based off of a percentage value.
#' 
#'@param percent_val a percentage value representing tax revenue
#'@return string of either "Large", "Medium", "Small Share"
categorize_tax_v <- function(percent_val) {
  ifelse(
    percent_val > 30, "Large Share",
    ifelse(percent_val > 10, "Medium Share", "Small Share")
  )
}

categorize_tax_v(pct_tr_21)
```
:::

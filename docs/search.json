[
  {
    "objectID": "Day2.html#section",
    "href": "Day2.html#section",
    "title": "MA-500 Intro to R",
    "section": ":::",
    "text": ":::\nConditionals\n\n\n\nExample: Write an if-else statement that prints the letter grade based off of the numeric scores.\n\nA: 90 or higher\nB: 75-89\nC: less than 75"
  },
  {
    "objectID": "Day2.html#t",
    "href": "Day2.html#t",
    "title": "MA-500 Intro to R",
    "section": "T",
    "text": "T\n\n\noutput$phonePhot &lt;- renderPlot({\n  \n})"
  },
  {
    "objectID": "Day2.html#t-1",
    "href": "Day2.html#t-1",
    "title": "MA-500 Intro to R",
    "section": "T",
    "text": "T\n\n\noutput$phonePlot &lt;- renderPlot({\n  # Render a barplot\n  barplot(WorldPhones[,input$region]*1000, \n          main=input$region,\n          ylab=\"Number of Telephones\",\n          xlab=\"Year\")\n})"
  },
  {
    "objectID": "Day2.html#conditionals-1",
    "href": "Day2.html#conditionals-1",
    "title": "MA-500 Intro to R",
    "section": "Conditionals",
    "text": "Conditionals\n\n\n\nhide code\nif (condition) {\n do if TRUE \n} else {\ndo if FALSE\n}"
  },
  {
    "objectID": "Day2.html#conditionals",
    "href": "Day2.html#conditionals",
    "title": "MA-500 Intro to R",
    "section": "Conditionals",
    "text": "Conditionals\n\nConditionals (e.g., if, else if, else) let you run certain sections of code only if a specific condition is true. This is useful when you want your program to make decisions or take different paths depending on the situation."
  },
  {
    "objectID": "Day2.html#conditionals-2",
    "href": "Day2.html#conditionals-2",
    "title": "MA-500 Intro to R",
    "section": "Conditionals",
    "text": "Conditionals\n\n\n\nhide code\nif (condition) {\n do something\n} else if (condition2) {\n do something\n} else {\ndo this instead\n}\n\n\n\n\n\nConditionals\n\n\n\n\n\n\nExample: Write an if-else statement that prints the letter grade based off of the numeric scores.\n\nA: 90 or higher\nB: 75-89\nC: less than 75\n\n\n\n\n\n#| edit: true\n#| min-lines: 3\n\n\n\n\nFunctions\n\nFunctions let you group code into reusable blocks. Instead of repeating the same code in multiple places, you can define it once and call it whenever you need. Functions can also take inputs (arguments) and return outputs (results).\n\n\n\n\nFunctions\n\n\n\nhide code\n# Define a function\nfunction_name &lt;- function(arg1, arg2, ...) {\n  \n  # do something here with arg1 and arg2\n  \n  # Step 3: Return the result\n  return(result)\n}\n\n\n# Call (use) the function\nfunction_name(value1, value2)\n\n\n\n\n\n\nFunctions\n\n\n\nhide code\n#' purpose of this function\n#'\n#' @param arg1 define arg1\n#' @param arg2 define arg2\n#'\n#' @return description \nfunction_name &lt;- function(arg1, arg2, ...) {\n  \n  # do something here with arg1 and arg2\n  \n  # Step 3: Return the result\n  return(result)\n}\n\n\n# Call (use) the function\nfunction_name(value1, value2)\n\n\n\n\n\n\nFunctions\n\n\n\n\n\n\nExample: Write a function that assigns the letter grade based off of the numeric scores.\n\nA: 90 or higher\nB: 75-89\nC: less than 75\n\n\n\n\n\n#| edit: true\n#| min-lines: 3\n\n\n\n\nRecursive Functions\nA recursive function is a function that calls itself to solve smaller instances of the same problem. It’s particularly useful for tasks that can be broken down into simpler, repetitive sub-tasks\n\n\n\nFactorials\n\n\n\n\n\n\nExample: Calculate the factorial of a non-negative integer n,\n\\[n! = n \\times (n - 1) \\times (n - 2) \\times . . . \\times 2 \\times 1 \\]\n\n\n\n\n\n\nFactorials\n\n\n\n\n\n\nExample: Calculate the factorial of a non-negative integer n,\n\\[n! = n \\times (n - 1) \\times (n - 2) \\times . . . \\times 2 \\times 1 \\]\n\n\n\n\n\nhide code\n#' Calculate the factorial of a given integer using recursion\n#'\n#' @param n non-negative integer\n#' @return n!\nfactorial_recursive &lt;- function(n) {\n if(n == 0) {\n  return(1)\n } else {\n  return(n * factorial_recursive(n-1))\n }\n}\n\n\n\n#| edit: true\n#| min-lines: 4\n\n\n\n\nLoops\n\nLoops (e.g., for, while) allow you to repeat sections of code multiple times without writing them out again. This is especially helpful when performing the same task on many items, such as processing each value in a dataset.\n\n\n\nhide code\nfor (loopindex in vector) {\n  do this\n}"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "MA500: Introduction to R",
    "section": "",
    "text": "MA-500: Introduction to R\nFANUCHÅNAN 2025: 8/20/2025 - 10/11/2025\nInstructor Information\nRegina-Mae Dominguez | dominguezr@triton.uog.edu\nOffice Hours & Location: Online by Appointments",
    "crumbs": [
      "MA-500: Introduction to R"
    ]
  },
  {
    "objectID": "index.html#course-introduction",
    "href": "index.html#course-introduction",
    "title": "MA500: Introduction to R",
    "section": "Course Introduction",
    "text": "Course Introduction\nThis markdown site will include notes, guides, and resources, while Moodle will be the central hub for the course as well as the platform for uploading and submitting homework assignments. As the course progresses, this site will be regularly updated to ensure it’s helpful, easy to navigate, and accessible whenever you need a reference. While this resource is designed to be useful, I strongly encourage you to take your own notes for a more personalized and detailed study guide.",
    "crumbs": [
      "MA-500: Introduction to R"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "References"
  },
  {
    "objectID": "04_CLF.html",
    "href": "04_CLF.html",
    "title": "Conditionals, Loops, and Functions",
    "section": "",
    "text": "Templates\nWhen you need to control the flow and logic of your code, you can use conditional statements, loops, or functions.",
    "crumbs": [
      "Conditionals, Loops, and Functions"
    ]
  },
  {
    "objectID": "04_CLF.html#templates",
    "href": "04_CLF.html#templates",
    "title": "Conditionals, Loops, and Functions",
    "section": "",
    "text": "If-Else\n\n\nhide code\nif (condition) {\n do something\n} else if (condition2) {\n do something\n} else {\ndo this instead\n}\n\n\n\n\nFunctions\n\n\nhide code\n#' purpose of this function\n#'\n#' @param arg1 define arg1\n#' @param arg2 define arg2\n#'\n#' @return description \nfunction_name &lt;- function(arg1, arg2, ...) {\n  \n  # do something here with arg1 and arg2\n  \n  # Step 3: Return the result\n  return(result)\n}\n\n\n# Call (use) the function\nfunction_name(value1, value2)\n\n\n\n\nLoops\n\n\nhide code\nfor (loopindex in vector) {\n  do this\n}",
    "crumbs": [
      "Conditionals, Loops, and Functions"
    ]
  },
  {
    "objectID": "04_CLF.html#if-else-1",
    "href": "04_CLF.html#if-else-1",
    "title": "Conditionals, Loops, and Functions",
    "section": "If-else",
    "text": "If-else\n\nWrite an if-else statement that prints the letter grade based off of the numeric scores.\n\nA: 90 or higher\nB: 75-89\nC: less than 75\n\nSolution:\n\n\nhide code\nscore &lt;- 80\n\nif (score &gt;= 90) {\n  print(\"A\") \n} else if (score &gt;= 75) {\n  print(\"B\")\n} else {\n  print(\"C\")\n}\n\n\n[1] \"B\"",
    "crumbs": [
      "Conditionals, Loops, and Functions"
    ]
  },
  {
    "objectID": "04_CLF.html#functions-1",
    "href": "04_CLF.html#functions-1",
    "title": "Conditionals, Loops, and Functions",
    "section": "Functions",
    "text": "Functions\nLet us extend our if-else statement from above and put it into a defined function that takes the numeric score as an input and outputs its respective letter grade.\n\nWrite a function that assigns the letter grade based off of the numeric scores.\n\nA: 90 or higher\nB: 75-89\nC: less than 75\n\nSolution:\n\n\nhide code\n#' This function returns a letter grade based off of their numeric grade.\n#' \n#' param @score numeric score from 0-100\n#' return A,B,C\nget_grade &lt;- function(score) {\n  if (score &gt;= 90) {\n  grade &lt;- \"A\"\n} else if (score &gt;= 75) {\n  grade &lt;- \"B\"\n} else {\n  grade &lt;- \"C\"\n}\n  return(grade)\n}\n\n# call the function\nget_grade(80)\n\n\n[1] \"B\"\n\n\nhide code\nget_grade(100)\n\n\n[1] \"A\"\n\n\nhide code\nget_grade(8)\n\n\n[1] \"C\"\n\n\n\n\nRecursive Functions\nA recursive function is a function that calls itself to solve smaller instances of the same problem. It’s particularly useful for tasks that can be broken down into simpler, repetitive sub-tasks.\n\nCalculate the factorial of a non-negative integer n,\n\\[n! = n \\times (n - 1) \\times (n - 2) \\times . . . \\times 2 \\times 1 \\]\nSolution:\n\n\nhide code\n#' Calculate the factorial of a given integer using recursion\n#'\n#' @param n non-negative integer\n#' @return n!\nfactorial_recursive &lt;- function(n) {\n if(n == 0) {\n  return(1)\n } else {\n  return(n * factorial_recursive(n-1))\n }\n}\n\nfactorial_recursive(6)\n\n\n[1] 720\n\n\n\nNote: R already has a base function called factorial.\n\n\n\n\n\n\nImportant\n\n\n\n\n\nhide code\nsum &lt;- function(x) {\n  x + y\n}\n\n# y is defined in your global environment (if you look at your list of variables)\ny &lt;- 15\nsum(12)\n\n\n[1] 27\n\n\nR uses lexical scoping to find the value associated with a variable name. Since `y` is not defined in the function, R will look in your environment.",
    "crumbs": [
      "Conditionals, Loops, and Functions"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "Summary",
    "section": "",
    "text": "Summary\nIn summary, this book has no content whatsoever.\n\n\nhide code\n1 + 1\n\n\n[1] 2"
  },
  {
    "objectID": "Day2.html",
    "href": "Day2.html",
    "title": "MA-500 Intro to R",
    "section": "",
    "text": "#| edit: false\n#| output: false\nwebr::install(\"gradethis\", quiet = TRUE)\nlibrary(gradethis)\noptions(webr.exercise.checker = function(\n  label, user_code, solution_code, check_code, envir_result, evaluate_result,\n  envir_prep, last_value, engine, stage, ...\n) {\n  if (is.null(check_code)) {\n    # No grading code, so just skip grading\n    invisible(NULL)\n  } else if (is.null(label)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = \"All exercises must have a label.\"\n    )\n  } else if (is.null(solution_code)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = htmltools::tags$div(\n        htmltools::tags$p(\"A problem occurred grading this exercise.\"),\n        htmltools::tags$p(\n          \"No solution code was found. Note that grading exercises using the \",\n          htmltools::tags$code(\"gradethis\"),\n          \"package requires a model solution to be included in the document.\"\n        )\n      )\n    )\n  } else {\n    gradethis::gradethis_exercise_checker(\n      label = label, solution_code = solution_code, user_code = user_code,\n      check_code = check_code, envir_result = envir_result,\n      evaluate_result = evaluate_result, envir_prep = envir_prep,\n      last_value = last_value, stage = stage, engine = engine)\n  }\n})"
  },
  {
    "objectID": "03_Basics.html",
    "href": "03_Basics.html",
    "title": "R Basics & Fundamentals",
    "section": "",
    "text": "R Markdown\nThis is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com.\nWhen you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:\nImportant commands when using RMarkdown: Use the / to quick insert markdown elements: R code chunk, Heading/Format Options, etc.\nIn-line code notation: ` &lt;- symbol with ~ on keyboard?",
    "crumbs": [
      "R Basics & Fundamentals"
    ]
  },
  {
    "objectID": "03_Basics.html#r-markdown",
    "href": "03_Basics.html#r-markdown",
    "title": "R Basics & Fundamentals",
    "section": "",
    "text": "This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com.\nWhen you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:\nImportant commands when using RMarkdown: Use the / to quick insert markdown elements: R code chunk, Heading/Format Options, etc.\nIn-line code notation: ` &lt;- symbol with ~ on keyboard?"
  },
  {
    "objectID": "03_Basics.html#comments",
    "href": "03_Basics.html#comments",
    "title": "R Basics & Fundamentals",
    "section": "Comments",
    "text": "Comments\nIt is recommended to always comment/annotate your code to make concepts clear. In R, we use the # symbol to indicate a comment.\n\n\nhide code\n# this is a comment \n\n#' \n#' this is a multi-line comment\n#'",
    "crumbs": [
      "R Basics & Fundamentals"
    ]
  },
  {
    "objectID": "03_Basics.html#using-r-as-a-calculator",
    "href": "03_Basics.html#using-r-as-a-calculator",
    "title": "R Basics & Fundamentals",
    "section": "Using R as a calculator",
    "text": "Using R as a calculator\n\n\nhide code\n# in either a script or the console, you can use it to solve basic arithmentic\n1 / 200 * 30\n\n\n[1] 0.15\n\n\nhide code\nsin(pi/2)\n\n\n[1] 1",
    "crumbs": [
      "R Basics & Fundamentals"
    ]
  },
  {
    "objectID": "03_Basics.html#r-packages",
    "href": "03_Basics.html#r-packages",
    "title": "R Basics & Fundamentals",
    "section": "R Packages",
    "text": "R Packages\nThe base installation of R consists of many in-house functions and commands, but more specialized techniques would require the installation of packages. A few packages that you should have for this course and I would recommend downloading are:\n\nggplot2\nMASS\nstats\ntidyverse/dplyr\n\nNote: If you are using a mac, some development packages would require you to install XQuartz or XCode. If issues come up with installing a package or getting a package to work, please let me know so I can help you out!\nFind more packages here: https://cran.r-project.org/\n\n\nhide code\n# how to install packages\ninstall.packages(\"MASS\")\n\n\n\n\nhide code\n# calling the package after installation\nlibrary(\"MASS\")\n\n\n\n\nhide code\n# updating packages/all packages\nupdate.packages()",
    "crumbs": [
      "R Basics & Fundamentals"
    ]
  },
  {
    "objectID": "03_Basics.html#directories",
    "href": "03_Basics.html#directories",
    "title": "R Basics & Fundamentals",
    "section": "Directories",
    "text": "Directories\nWhen you run RStudio, your session is typically associated with a working directory. This is the default location where your files are imported or saved.\n\n\nhide code\n# check your working directory with this function\ngetwd()\n\n\n[1] \"/Users/rdominguez/Documents/MA500/Fall25/ma500_fall2025\"\n\n\n\n\nhide code\nsetwd(\"/insertFilePathHere\")",
    "crumbs": [
      "R Basics & Fundamentals"
    ]
  },
  {
    "objectID": "03_Basics.html#variables",
    "href": "03_Basics.html#variables",
    "title": "R Basics & Fundamentals",
    "section": "Variables",
    "text": "Variables\nYou can save and create new objects to store your results by using &lt;- (as opposed to the conventional = which is used with named function assignments.)\n\n\nhide code\n# store the result of 4*3 into x\n\nx &lt;- 4 * 3\n\n# print x (assignment alone does not print output)\nprint(x)\n\n\n[1] 12\n\n\nNote: R is a dynamic language, so the types and values can easily be changed. (type checks are done during run-time)\n\n\nhide code\n# x is now a of type character\nx &lt;- \"statistics\"",
    "crumbs": [
      "R Basics & Fundamentals"
    ]
  },
  {
    "objectID": "03_Basics.html#r-data-types",
    "href": "03_Basics.html#r-data-types",
    "title": "R Basics & Fundamentals",
    "section": "R data types",
    "text": "R data types\nA data type describes the kind of values a variable can hold and how R will interpret and use those values in calculations, comparisons, and functions. Choosing/creating the right data type is important because it affects how R stores information and what operations you can perform.\nR data types include:\n\nnumeric:\n\ndouble values with decimals\nint whole numbers\n\ncharacter – text or strings (\"Hello\")\nlogical – TRUE/FALSE values\nfactor – categorical data (\"A\", \"B\")\n\nUse the class() function to determine what data type your variable is:\n\n\nhide code\nclass(2L)\n\n\n[1] \"integer\"\n\n\nhide code\nclass(2)\n\n\n[1] \"numeric\"",
    "crumbs": [
      "R Basics & Fundamentals"
    ]
  },
  {
    "objectID": "03_Basics.html#data-vectors",
    "href": "03_Basics.html#data-vectors",
    "title": "R Basics & Fundamentals",
    "section": "Data Vectors",
    "text": "Data Vectors\nAn R data vector is a collection of observations or measurements concerning a single variable of the same data type (all numeric, all character, all logical, etc.). The c() function takes individual values and combines them into a single vector.\n\nIn 2021, the average temperature in Guam for each month was 80.7, 81.4, 81.5, 82.6, 82.6, 83.7, 83.4, 81.8, 82.5, 81.4, 82.0, and 81.0. Store these values in a vector named temp.\nSolution:\n\n\nhide code\ntemp &lt;- c(80.7, 81.4, 81.5, 82.6, 82.6, 83.7, 83.4, 81.8, 82.5, 81.4, 82.0, 81.0)\n\n\n\n\n\nhide code\n# returns the length of temp \nlength(temp)\n\n\n[1] 12\n\n\n\n\nhide code\n# we can perform these function because all values in temp is a numeric value\nsum(temp)\n\n\n[1] 984.6\n\n\n\n\nhide code\nmean(temp)\n\n\n[1] 82.05\n\n\nIn the case you have a NA in your vector, sum() and mean() will return NA. To bypass that, you need to include the argument: na.rm = TRUE.\n\nAttributes\nVectors can be assigned attributes or names.\n\n\nhide code\nmonths &lt;- c(\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"July\",\n    \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\")\n\nnames(temp) &lt;- months\nprint(temp)\n\n\n Jan  Feb  Mar  Apr  May  Jun July  Aug  Sep  Oct  Nov  Dec \n80.7 81.4 81.5 82.6 82.6 83.7 83.4 81.8 82.5 81.4 82.0 81.0 \n\n\n\n\nIndexing\nYou can call a specific value in the temp vector by referencing its respective name.\n\n\nhide code\n# get the average temperature in May\ntemp[\"May\"]\n\n\n May \n82.6 \n\n\nOR, you can index the vector by referencing its numeric index value.\n\n\nhide code\n# grabs the first value\ntemp[1]\n\n\n Jan \n80.7 \n\n\nhide code\n# grab the first 4 values\ntemp[1:4]\n\n\n Jan  Feb  Mar  Apr \n80.7 81.4 81.5 82.6 \n\n\n\n\nOperators\nOperators are symbols that tell R what kind of computation to perform on values or variables. They are the building blocks for calculations, comparisons, and logical expressions.\n\nComparison:\n\n&gt; greater than\n&lt; less than\n&lt;= less than or equal to\n&gt;= greater than or equal to\n== equal to\n!= not equal to\n\n\nWhat months have a higher average temperature compared to August?\nSolution:\n\n\nhide code\ntemp[temp &lt; temp[\"Aug\"]]\n\n\n Jan  Feb  Mar  Oct  Dec \n80.7 81.4 81.5 81.4 81.0 \n\n\n\nLet’s break the line of code down:\n\ntemp['Aug'] : refers to the temperature in August.\ntemp &gt; temp['Aug'] : checks all values of the temp vector to check if this statement is true\ntemp[temp &gt; temp['Aug']]: returns only the months & values where the second bullet is true.\n\n\n\nLogical\n\n& AND\n| OR\n! NOT\n\n\n\n\nUsing or operator:\nWhat FALL months have a higher average temperature than August?\nSolution:\n\n\nhide code\n# let's define a vector that contains the fall months \n\nfall &lt;- c(\"Sep\", \"Oct\", \"Nov\")\ntemp[temp &gt; temp[\"Aug\"] | names(temp) %in% fall]\n\n\n Apr  May  Jun July  Sep  Oct  Nov \n82.6 82.6 83.7 83.4 82.5 81.4 82.0 \n\n\n\n\nnames(temp) : calls the attributes of the temp vector\n%in% : a special operator that checks if elements exist in a vector\nnames(temp) %in% fall : checks which attributes are in the fall vector\n\n\nUsing equals operator:\nWhat month had the highest average temperature?\nSolution:\n\n\nhide code\ntemp[temp == max(temp)]\n\n\n Jun \n83.7 \n\n\nOR if we want just the name of the month, we can index the value from the names attribute:\n\n\nhide code\nnames(temp)[temp == max(temp)]\n\n\n[1] \"Jun\"\n\n\n\n\nWhat is the average temperature in the summer months?\nSolution:\n\n\nhide code\ntemp[c(\"Jun\", \"July\", \"Aug\")]\n\n\n Jun July  Aug \n83.7 83.4 81.8 \n\n\nhide code\nsummer_months &lt;- c(\"Jun\", \"July\", \"Aug\")\nsummer_temps &lt;- temp[summer_months]\n\naverage_summer &lt;- mean(summer_temps)\nprint(average_summer)\n\n\n[1] 82.96667",
    "crumbs": [
      "R Basics & Fundamentals"
    ]
  },
  {
    "objectID": "03_Basics.html#vector-operations",
    "href": "03_Basics.html#vector-operations",
    "title": "R Basics & Fundamentals",
    "section": "Vector Operations",
    "text": "Vector Operations\nWith vectors, you can utilize element-wise basic arithmetic.\nFor example, if we want to add 2 degrees to every temperature in the temp data vector, then we can define that as:\n\n\nhide code\ntemp &lt;- temp + 2\n\n\n\nVector Operation\nConvert all temperatures in our temp vector from Fahrenheit to Celsius.\nWe are going to apply this formula:\n\\[\nC = \\frac{5}{9}*(t - 32)\n\\]\nto all values in our temp vector.\nSolution:\n\n\nhide code\ntemp_celcius &lt;- (5/9) * (temp - 32)\n\n\nAll attributes are retained and all values are converted.\n\nExample: \n\nConvert all temperatures from Fahrenheit to Celciu",
    "crumbs": [
      "R Basics & Fundamentals"
    ]
  },
  {
    "objectID": "03_Basics.html#sequences-and-repetition",
    "href": "03_Basics.html#sequences-and-repetition",
    "title": "R Basics & Fundamentals",
    "section": "Sequences and Repetition",
    "text": "Sequences and Repetition\nR has in-house functions that allow you to create a sequence of values (or repeat).\nWe will be using seq and rep, and you can read up for help on the documentation by using ?function in R. This pulls up the documentation and example usage\n\nSequence\nWithout a function, the easiest way to create a sequence with intervals of 1 is using the colon operator\n\n\nhide code\nprint(1:10)\n\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nFor more flexible sequences, we can use the seq function:\n\n\nSequence List\nCreate a list of every 3rd value from 1 to 20\n\n\nhide code\nseq(from = 1, to = 20, by = 3)\n\n\n[1]  1  4  7 10 13 16 19\n\n\nNote: This will always include the from value, but NOT the to value. This is dependent on the by number.\n\nInstead of specifying a by number, you can specify how many numbers you would like in between with length.out - this would be equally spaced.\n\n\nhide code\nseq(from = 1, to = 10, length.out = 20)\n\n\n [1]  1.000000  1.473684  1.947368  2.421053  2.894737  3.368421  3.842105\n [8]  4.315789  4.789474  5.263158  5.736842  6.210526  6.684211  7.157895\n[15]  7.631579  8.105263  8.578947  9.052632  9.526316 10.000000\n\n\nFor decreasing, set `by` to be a negative value and switch the from and to values.\n\n\nhide code\nseq(from = 10, to = 1, by = -3)\n\n\n[1] 10  7  4  1",
    "crumbs": [
      "R Basics & Fundamentals"
    ]
  },
  {
    "objectID": "03_Basics.html#random-sampling",
    "href": "03_Basics.html#random-sampling",
    "title": "R Basics & Fundamentals",
    "section": "Random Sampling",
    "text": "Random Sampling\nThe sample() function takes a sample from the specified elements of x with or without replacement.\n\nCreating a sample\nCreate a random sample of 20 values ranging from 1 to 100 with replacement.\n\n\nhide code\nsample(1:100, 20, replace = T)\n\n\n [1] 63  8 23 52 89 57 20 11 29 99 49 16  2 31 45 44 59 24 51 52\n\n\n\nNote: running the above code again will not give you the same output:\n\n\nhide code\nsample(1:100, 20, replace = T)\n\n\n [1] 76 82 68 90 18 62 20 38 21 35 94 26 99 47 60 12 54 30 81  6\n\n\nIf you would like to replicate the same results every time, we have to set a seed by using the set.seed(x) function, where x is any arbitrary number.\n\n\nhide code\nset.seed(415)\nsample(1:100, 20, replace = T)\n\n\n [1]  2 94 70 11 91 35 56 47 34 39  1 18 60 29 68  9 70 45 53 67\n\n\n\nRepetition\nTo repeat values in a vector, use the rep() function.\n\n\nhide code\n# repeat 1 four times \nrep(x = 1, times = 4)\n\n\n[1] 1 1 1 1\n\n\nhide code\n# repeat 1 to 5, 10 times\nrep(1:5, times = 10)\n\n\n [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3\n[39] 4 5 1 2 3 4 5 1 2 3 4 5\n\n\nhide code\n# repeat 1, 2, 5, 7 each values twice\nrep(x = c(1, 2, 5, 7), times = 3, each = 2)\n\n\n [1] 1 1 2 2 5 5 7 7 1 1 2 2 5 5 7 7 1 1 2 2 5 5 7 7\n\n\nhide code\n# repeat each element in x by specified vector time (1\n# once, 2 four times, 5, once, and 7 twice)\nrep(x = c(1, 2, 5, 7), times = c(1, 4, 1, 2))\n\n\n[1] 1 2 2 2 2 5 7 7",
    "crumbs": [
      "R Basics & Fundamentals"
    ]
  },
  {
    "objectID": "01_install.html",
    "href": "01_install.html",
    "title": "R/RStudio Installation Guide",
    "section": "",
    "text": "Installing R\nTo install R, begin by visiting the Comprehensive R Archive Network (CRAN) here: https://cran.r-project.org/. Select and download the appropriate R binary package for your operating system— whether Windows, macOS, or Linux. For Mac users, please be sure that you install the correct package binary associated with your processor (e.g., Intel or Apple Silicon).",
    "crumbs": [
      "R/RStudio Installation Guide"
    ]
  },
  {
    "objectID": "01_install.html#installing-rstudio",
    "href": "01_install.html#installing-rstudio",
    "title": "R/RStudio Installation Guide",
    "section": "Installing RStudio",
    "text": "Installing RStudio\nRStudio is the most widely used integrated development environment (IDE) for R programming. You can download the free version here: https://posit.co/downloads/. Whie you have the option to use alternative IDEs, such as VS Code with the Rtools extention or the base R GUI, it is recommended to use RStudio as the course material will primarily be demonstrated using this IDE. This will ensure you can easily follow along with the course content!",
    "crumbs": [
      "R/RStudio Installation Guide"
    ]
  },
  {
    "objectID": "04_CLF.html#case-study-govguam-tax-revenue",
    "href": "04_CLF.html#case-study-govguam-tax-revenue",
    "title": "Conditionals, Loops, and Functions",
    "section": "Case Study: GovGuam Tax Revenue",
    "text": "Case Study: GovGuam Tax Revenue\nLet’s examine the table showing Government of Guam tax revenue from 2017-2022 from the 2023 Guam Statistical Yearbook.\n\n\nTo-dos:*\n\nMake two separate vectors: one for the dollar amounts in each category (excluding the total) for 2022, and another for 2021.\nAdd attributes to each vector that describe what the values represent (the category or description).\nFind the difference in tax revenue between 2021 and 2022 in each category.\nBuild two vectors that calculate what percent of the total revenue comes from each category for 2022 and 2021.\nWrite a function that takes in a percentage value (e.g., the share of a tax category) and classifies it into these categories:\n\n&gt; 30% : Large Share\n&gt; 10% : Medium Share\n&lt; 10% : Small Share\n\nUse a for loop to categorize each value in our vectors.\n\n\n\nMake two separate vectors: one for the dollar amounts in each category (excluding the total) for 2022, and another for 2021.\n\n\n\nhide code\n# 2021 tax rev values\ntr_21 &lt;- c(352818, 296806, 65110, 35612, 12372, 10100, 34978, 3519, 3761, 1395, 0)\n\n# 2022 tax rev values\ntr_22 &lt;- c(372492, 327115, 76141, 35794, 18169, 9353, 31643, 4953, 3562, 1473, 0)\n\n\n\nAdd attributes to each vector that describe what the values represent (the category or description).\n\n\n\nhide code\ncategories &lt;- c(\"Income\", \"Gross Receipts\", \"Section 30 Federal income tax\", \"Property\", \"Hotel Occupancy\", \"Liquid Fuel\", \"Tabacco\", \"Alcoholic Beverages\", \"Excise\", \"Lmited Gaming\", \"Other\")\n\nnames(tr_21) &lt;- categories\nnames(tr_22) &lt;- categories\n\n## -- OR\n\ntr_21 &lt;- c(\"Income\" = 352818, \"Gross Receipts\" = 296806, \"Section 30 Federal income tax\" = 65110, \n           \"Property\" = 35612, \"Hotel Occupancy\" = 12372, \"Liquid Fuel\" = 10100, \"Tabacco\" = 34978, \n           \"Alcoholic Beverages\" = 3519, \"Excise\" = 3761, \"Lmited Gaming\" = 1395, \"Other\" = 0)\n\ntr_22 &lt;- c(\"Income\" = 372492, \"Gross Receipts\" = 327115, \"Section 30 Federal income tax\" = 76141, \n           \"Property\" = 35794, \"Hotel Occupancy\" = 18169, \"Liquid Fuel\" = 9353, \"Tabacco\" = 31643, \n           \"Alcoholic Beverages\" = 4953, \"Excise\" = 3562, \"Lmited Gaming\" = 1473, \"Other\" = 0)\n\n\n\nFind the difference in tax revenue between 2021 and 2022 in each category.\n\n\n\nhide code\ndiff_taxRev &lt;- tr_22 - tr_21\n\n\n\nBuild two vectors that calculate what percent of the total revenue comes from each category for 2022 and 2021.\n\n\n\nhide code\n# grab the total number of tax revenue from all categories for both years\ntotal_22 &lt;- sum(tr_22)\ntotal_21 &lt;- sum(tr_21)\n\n# divide each category by total and multiply by 100 to get percent\npct_tr_21 &lt;- tr_21/total_21 * 100\npct_tr_22 &lt;- tr_22/total_22 * 100\n\n\n\nWrite a function that takes in a percentage value and classifies it into these categories: &gt;30%: Large Share, &gt;10%: Medium Share, &lt;10%: Small Share\n\n\n\nhide code\n#' This function groups the share sizes based off of a percentage value.\n#' \n#'@param percent_val a percentage value representing tax revenue\n#'@return string of either \"Large\", \"Medium\", \"Small Share\"\ncategorize_tax &lt;- function(percent_val) {\n  if (percent_val &gt; 30) {\n    share &lt;- \"Large Share\"\n  } else if (percent_val &gt; 10) {\n    share &lt;- \"Medium Share\"\n  } else {\n    share &lt;- \"Small Share\"\n  }\n  return(share)\n}\n\n# test each possible case\ncategorize_tax(40)\n\n\n[1] \"Large Share\"\n\n\nhide code\ncategorize_tax(12)\n\n\n[1] \"Medium Share\"\n\n\nhide code\ncategorize_tax(9)\n\n\n[1] \"Small Share\"\n\n\n\nUse a for loop to categorize each value in our vectors. Check how many of each share we have.\n\n\n\nhide code\nshare_categories &lt;- c()\nfor (pct in pct_tr_21) {\n  share_categories &lt;- append(share_categories, categorize_tax(pct))\n  \n}",
    "crumbs": [
      "Conditionals, Loops, and Functions"
    ]
  },
  {
    "objectID": "03_Basics.html#lets-move-onto-r-basics",
    "href": "03_Basics.html#lets-move-onto-r-basics",
    "title": "R Basics & Fundamentals",
    "section": "Let’s move onto R Basics!",
    "text": "Let’s move onto R Basics!",
    "crumbs": [
      "R Basics & Fundamentals"
    ]
  },
  {
    "objectID": "04_CLF.html#lists-vs.-vectors",
    "href": "04_CLF.html#lists-vs.-vectors",
    "title": "Conditionals, Loops, and Functions",
    "section": "Lists vs. Vectors",
    "text": "Lists vs. Vectors\nA vector is a one dimensional array of elements that must be the SAME type. Almost all data in R is stored in a vector.\nA list is a recursive vector, meaning a list can contain multiple vectors or other lists. Lists can contain lists of vectors or lists of dataframes. Lists can contain any data-type.\n\nCreate/Define a list.\nSolution:\n\n\nhide code\n# vector num: numeric\nnum &lt;- c(1,8,9,2)\n\n# vector char: character \nchar &lt;- c(\"Apple\", \"Banana\")\n\n# list: l combination of num and char\nl &lt;- list(num, char)\nprint(l)\n\n\n[[1]]\n[1] 1 8 9 2\n\n[[2]]\n[1] \"Apple\"  \"Banana\"\n\n\n\n\nIndexing a list:\n\n\nhide code\n# returns the first element of the list \n# single bracket - returns as a list\nprint(l[1])\n\n\n[[1]]\n[1] 1 8 9 2\n\n\nhide code\n# double bracker - returns back the vector\nprint(l[[1]])\n\n\n[1] 1 8 9 2\n\n\nhide code\n# returns the second element of the list\nprint(l[2])\n\n\n[[1]]\n[1] \"Apple\"  \"Banana\"\n\n\nhide code\nprint(l[[2]])\n\n\n[1] \"Apple\"  \"Banana\"\n\n\nhide code\n# returns the 3rd element of the vector in the first element of the list\nprint(l[[1]][3])\n\n\n[1] 9\n\n\nhide code\n# setting names in the list\nnames(l) &lt;- c(\"num\", \"char\")\n\n# indexing using names\nprint(l$num[3])\n\n\n[1] 9\n\n\n\n\nThe apply() family\nThe apply() family are several functions in R that provide a way to apply functions across different data structures without the need to write explicit loops. These functions allow you to work more efficiently with vectors, lists, dataframes, and in a much cleaner way.\n\n\n\n\n\n\n\n\n\nFunction\nInput\nOutput\nDescription\n\n\n\n\napply()\n\nMatrix\nDataframe\n\n\nVector\nArray\n\nApplies a specified function across rows or columns\n\n\nlapply()\n\nList\nVector\n\n\nList\n\nApplies a function to each element; always returns a list\n\n\nsapply()\n\nList\n\n\n\nVector\n\n\nVector\nMatrix\nList\n\nsame as sapply() but returns the most simplified version it can return\n\n\n\nLet’s use some of the functions above to categorize our tax revenue percentage vectors with the above share_categories() function.\n\n\nhide code\ncategories &lt;- lapply(pct_tr_21, categorize_tax)\nprint(categories)\n\n\n$Income\n[1] \"Large Share\"\n\n$`Gross Receipts`\n[1] \"Large Share\"\n\n$`Section 30 Federal income tax`\n[1] \"Large Share\"\n\n$Property\n[1] \"Large Share\"\n\n$`Hotel Occupancy`\n[1] \"Large Share\"\n\n$`Liquid Fuel`\n[1] \"Large Share\"\n\n$Tabacco\n[1] \"Large Share\"\n\n$`Alcoholic Beverages`\n[1] \"Large Share\"\n\n$Excise\n[1] \"Large Share\"\n\n$`Lmited Gaming`\n[1] \"Large Share\"\n\n$Other\n[1] \"Small Share\"\n\n\nhide code\nclass(categories)\n\n\n[1] \"list\"\n\n\n\n\nhide code\ncategories_sapply &lt;- sapply(pct_tr_21, categorize_tax)\nprint(categories_sapply)\n\n\n                       Income                Gross Receipts \n                \"Large Share\"                 \"Large Share\" \nSection 30 Federal income tax                      Property \n                \"Large Share\"                 \"Large Share\" \n              Hotel Occupancy                   Liquid Fuel \n                \"Large Share\"                 \"Large Share\" \n                      Tabacco           Alcoholic Beverages \n                \"Large Share\"                 \"Large Share\" \n                       Excise                 Lmited Gaming \n                \"Large Share\"                 \"Large Share\" \n                        Other \n                \"Small Share\" \n\n\nhide code\nclass(categories_sapply)\n\n\n[1] \"character\"",
    "crumbs": [
      "Conditionals, Loops, and Functions"
    ]
  },
  {
    "objectID": "04_CLF.html#vectorized-functions",
    "href": "04_CLF.html#vectorized-functions",
    "title": "Conditionals, Loops, and Functions",
    "section": "Vectorized Functions",
    "text": "Vectorized Functions\nMost base R functions are vectorized, meaning they automatically apply the function or operation to every element in a vector provided.\nOur function categorize_tax is NOT vectorized. You can see below that we can an error if we try to input the ENTIRE percent vector into the function.\n\n\n\n\n\n\nCaution\n\n\n\n\n\nhide code\ncategorize_tax(pct_tr_21)\n\n\nError in if (percent_val &gt; 30) {: the condition has length &gt; 1\n\n\n\n\nTo make our categorize_tax function vectorized, we need to adjust the code. Rather than using nested if-else statements, we can use ifelse(), which is the vectorized version and works element-wise across an entire vector.\n\nNon-Vectorized Function vs Vectorized Function\nBefore vectorizing: (we need to run a loop using this function to do element-wise operations on it)\n\n\nhide code\n#' This function groups the share sizes based off of a percentage value.\n#' \n#'@param percent_val a percentage value representing tax revenue\n#'@return string of either \"Large\", \"Medium\", \"Small Share\"\ncategorize_tax &lt;- function(percent_val) {\n  if (percent_val &gt; 30) {\n    share &lt;- \"Large Share\"\n  } else if (percent_val &gt; 10) {\n    share &lt;- \"Medium Share\"\n  } else {\n    share &lt;- \"Small Share\"\n  }\n  return(share)\n}\n\n\nAfter vectoring: we can directly provide this function our vector and it will automatically perform element wise operations on it because the inner ifelse() is a vectorized function.\n\n\nhide code\n#' This function groups the share sizes based off of a percentage value.\n#' \n#'@param percent_val a percentage value representing tax revenue\n#'@return string of either \"Large\", \"Medium\", \"Small Share\"\ncategorize_tax_v &lt;- function(percent_val) {\n  ifelse(\n    percent_val &gt; 30, \"Large Share\",\n    ifelse(percent_val &gt; 10, \"Medium Share\", \"Small Share\")\n  )\n}\n\ncategorize_tax_v(pct_tr_21)\n\n\n                       Income                Gross Receipts \n                \"Large Share\"                 \"Large Share\" \nSection 30 Federal income tax                      Property \n                \"Large Share\"                 \"Large Share\" \n              Hotel Occupancy                   Liquid Fuel \n                \"Large Share\"                 \"Large Share\" \n                      Tabacco           Alcoholic Beverages \n                \"Large Share\"                 \"Large Share\" \n                       Excise                 Lmited Gaming \n                \"Large Share\"                 \"Large Share\" \n                        Other \n                \"Small Share\"",
    "crumbs": [
      "Conditionals, Loops, and Functions"
    ]
  },
  {
    "objectID": "04_CLF.html#to-do",
    "href": "04_CLF.html#to-do",
    "title": "Conditionals, Loops, and Functions",
    "section": " To-Do",
    "text": "To-Do\n\nNon-Vectorized Function vs Vectorized Function\nBefore vectorizing: (we need to run a loop using this function to do element-wise operations on it)\n\n\nhide code\n#' This function groups the share sizes based off of a percentage value.\n#' \n#'@param percent_val a percentage value representing tax revenue\n#'@return string of either \"Large\", \"Medium\", \"Small Share\"\ncategorize_tax &lt;- function(percent_val) {\n  if (percent_val &gt; 30) {\n    share &lt;- \"Large Share\"\n  } else if (percent_val &gt; 10) {\n    share &lt;- \"Medium Share\"\n  } else {\n    share &lt;- \"Small Share\"\n  }\n  return(share)\n}\n\n\nAfter vectoring: we can directly provide this function our vector and it will automatically perform element wise operations on it because the inner ifelse() is a vectorized function.\n\n\nhide code\n#' This function groups the share sizes based off of a percentage value.\n#' \n#'@param percent_val a percentage value representing tax revenue\n#'@return string of either \"Large\", \"Medium\", \"Small Share\"\ncategorize_tax_v &lt;- function(percent_val) {\n  ifelse(\n    percent_val &gt; 30, \"Large Share\",\n    ifelse(percent_val &gt; 10, \"Medium Share\", \"Small Share\")\n  )\n}\n\ncategorize_tax_v(pct_tr_21)\n\n\n                       Income                Gross Receipts \n                \"Large Share\"                 \"Large Share\" \nSection 30 Federal income tax                      Property \n                \"Small Share\"                 \"Small Share\" \n              Hotel Occupancy                   Liquid Fuel \n                \"Small Share\"                 \"Small Share\" \n                      Tabacco           Alcoholic Beverages \n                \"Small Share\"                 \"Small Share\" \n                       Excise                 Lmited Gaming \n                \"Small Share\"                 \"Small Share\" \n                        Other \n                \"Small Share\"",
    "crumbs": [
      "Conditionals, Loops, and Functions"
    ]
  },
  {
    "objectID": "05_Dataframes.html",
    "href": "05_Dataframes.html",
    "title": "Introduction to Dataframes",
    "section": "",
    "text": "What is a data.frame?\nA data.frame in R is a data structure used to store data in a tabular form. It is very similar to a spreadsheet, excel sheet, or SQL table within R. You can also think of it as a collection of multiple data vectors. A data.frame is two-dimensional, meaning it has rows and columns where:",
    "crumbs": [
      "Introduction to Dataframes"
    ]
  },
  {
    "objectID": "05_Dataframes.html#creating-a-data.frame",
    "href": "05_Dataframes.html#creating-a-data.frame",
    "title": "Introduction to Dataframes",
    "section": "Creating a Data.frame",
    "text": "Creating a Data.frame\nYou can build a data.frame either by defining it within R or by reading data from a .csv or .xlsx file.\n\nDefining in R\n\nLet’s add our previously defined vectors in a data.frame. \n\n\nhide code\ntr_21 &lt;- c(352818, 296806, 65110, 35612, 12372, 10100, 34978, 3519, 3761, 1395, 0)\ntr_22 &lt;- c(372492, 327115, 76141, 35794, 18169, 9353, 31643, 4953, 3562, 1473, 0)\ncategories &lt;- c(\"Income\", \"Gross Receipts\", \"Section 30 Federal income tax\", \"Property\", \"Hotel Occupancy\", \"Liquid Fuel\", \"Tabacco\", \"Alcoholic Beverages\", \"Excise\", \"Lmited Gaming\", \"Other\")\n\ntax_rev &lt;- data.frame(description = categories, \n                      tax_2021 = tr_21, \n                      tax_2022 = tr_22)\n\nprint(head(tax_rev))\n\n\n                    description tax_2021 tax_2022\n1                        Income   352818   372492\n2                Gross Receipts   296806   327115\n3 Section 30 Federal income tax    65110    76141\n4                      Property    35612    35794\n5               Hotel Occupancy    12372    18169\n6                   Liquid Fuel    10100     9353\n\n\n\n\n\nReading in a .csv\nTo read a separate .csv file into R, we will use the read_csv function from the readr package (also part of tidyverse).\n\n\n\nhide code\nlibrary(tidyverse)\n\n\n\n\nhide code\n# personal preference for me is to create a separate string that is my parent folder\ndir &lt;- \"/Users/rdominguez/Documents/MA500/Lessons/datasets/\"\now &lt;- read_csv(paste0(dir, \"overwatch_stats.csv\"))\n\n\nRows: 87 Columns: 12\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): Player, Date, Map, Mode, Role\ndbl (7): Win, Elimination, Assists, Deaths, Damage, Heals, Mitigation\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.",
    "crumbs": [
      "Introduction to Dataframes"
    ]
  },
  {
    "objectID": "05_Dataframes.html#analyzing-the-data",
    "href": "05_Dataframes.html#analyzing-the-data",
    "title": "Introduction to Dataframes",
    "section": "Analyzing the data",
    "text": "Analyzing the data\nOnce your data is loaded into R, the best first steps is to inspect it. The main focus: get familiar with the data and summarize its main characteristics.\nThe head() function displays the first 6 rows of your dataset\n\n\nhide code\nhead(ow)\n\n\n# A tibble: 6 × 12\n  Player  Date     Win Map   Mode  Role  Elimination Assists Deaths Damage Heals\n  &lt;chr&gt;   &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1 player1 8/15/…     1 Sura… Assa… Dama…          28       0      5  11480  2484\n2 player1 8/15/…     1 King… Atta… Dama…          17       3      4   6713     0\n3 player1 8/15/…     0 New … Robot Tank           27       4      7   5776   122\n4 player1 8/15/…     0 Midt… Atta… Dama…           8       3      6   7138     8\n5 player1 8/15/…     1 Ilios Atta… Supp…          10       3      4   2163  4849\n6 player1 8/15/…     1 Hava… Esco… Tank            7       2      9   4416  2498\n# ℹ 1 more variable: Mitigation &lt;dbl&gt;\n\n\nThe summary() function provides us with a statistical summary of each column or variable.\n\n\nhide code\nsummary(ow)\n\n\n    Player              Date                Win             Map           \n Length:87          Length:87          Min.   :0.0000   Length:87         \n Class :character   Class :character   1st Qu.:0.0000   Class :character  \n Mode  :character   Mode  :character   Median :1.0000   Mode  :character  \n                                       Mean   :0.6552                     \n                                       3rd Qu.:1.0000                     \n                                       Max.   :1.0000                     \n     Mode               Role            Elimination       Assists      \n Length:87          Length:87          Min.   : 4.00   Min.   : 0.000  \n Class :character   Class :character   1st Qu.:10.50   1st Qu.: 2.000  \n Mode  :character   Mode  :character   Median :15.00   Median : 6.000  \n                                       Mean   :16.68   Mean   : 8.747  \n                                       3rd Qu.:21.00   3rd Qu.:12.500  \n                                       Max.   :58.00   Max.   :51.000  \n     Deaths           Damage          Heals         Mitigation  \n Min.   : 0.000   Min.   :  773   Min.   :    0   Min.   :   0  \n 1st Qu.: 4.000   1st Qu.: 2974   1st Qu.:  100   1st Qu.:   0  \n Median : 6.000   Median : 4336   Median : 1322   Median :   0  \n Mean   : 5.989   Mean   : 5166   Mean   : 3214   Mean   :1156  \n 3rd Qu.: 8.000   3rd Qu.: 6994   3rd Qu.: 5898   3rd Qu.:1798  \n Max.   :12.000   Max.   :14824   Max.   :18620   Max.   :7253  \n\n\nThe str() function gives a structural overview of the data.\n\n\nhide code\nstr(ow)\n\n\nspc_tbl_ [87 × 12] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ Player     : chr [1:87] \"player1\" \"player1\" \"player1\" \"player1\" ...\n $ Date       : chr [1:87] \"8/15/24\" \"8/15/24\" \"8/15/24\" \"8/15/24\" ...\n $ Win        : num [1:87] 1 1 0 0 1 1 0 1 1 1 ...\n $ Map        : chr [1:87] \"Suravasa\" \"King's Row\" \"New Queen Street\" \"Midtown\" ...\n $ Mode       : chr [1:87] \"Assault\" \"Attack Escort\" \"Robot\" \"Attack Escort\" ...\n $ Role       : chr [1:87] \"Damage\" \"Damage\" \"Tank\" \"Damage\" ...\n $ Elimination: num [1:87] 28 17 27 8 10 7 22 15 27 8 ...\n $ Assists    : num [1:87] 0 3 4 3 3 2 6 3 8 5 ...\n $ Deaths     : num [1:87] 5 4 7 6 4 9 9 7 4 1 ...\n $ Damage     : num [1:87] 11480 6713 5776 7138 2163 ...\n $ Heals      : num [1:87] 2484 0 122 8 4849 ...\n $ Mitigation : num [1:87] 0 245 2082 828 0 ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   Player = col_character(),\n  ..   Date = col_character(),\n  ..   Win = col_double(),\n  ..   Map = col_character(),\n  ..   Mode = col_character(),\n  ..   Role = col_character(),\n  ..   Elimination = col_double(),\n  ..   Assists = col_double(),\n  ..   Deaths = col_double(),\n  ..   Damage = col_double(),\n  ..   Heals = col_double(),\n  ..   Mitigation = col_double()\n  .. )\n - attr(*, \"problems\")=&lt;externalptr&gt; \n\n\nAnother useful thing to analyze is looking at all the possible values in your columns - sometimes, the str() function shows all unique values, but other times it gets cut off. We can do it this way:\n\n\nhide code\n# output all unique values in the Player column \nunique(ow$Player)\n\n\n[1] \"player1\" \"player2\"\n\n\nhide code\n# OR use the apply function for the unique function\nlapply(ow, unique)\n\n\n$Player\n[1] \"player1\" \"player2\"\n\n$Date\n[1] \"8/15/24\" \"8/14/24\" \"8/13/24\" \"8/12/24\" \"8/16/24\" \"8/10/24\" \"8/17/24\"\n\n$Win\n[1] 1 0\n\n$Map\n [1] \"Suravasa\"              \"King's Row\"            \"New Queen Street\"     \n [4] \"Midtown\"               \"Ilios\"                 \"Havana\"               \n [7] \"Blizzard World\"        \"Junkertown\"            \"New Junk City\"        \n[10] \"Paraiso\"               \"Runasapi\"              \"Nepal\"                \n[13] \"Colosseo\"              \"Shambali Monastery\"    \"Busan\"                \n[16] \"Rialto\"                \"Oasis\"                 \"Eichenwalde\"          \n[19] \"Lijiang Tower\"         \"Route 66\"              \"Antarctic Peninsula\"  \n[22] \"Circuit Royal\"         \"Hollywood\"             \"Watchpoint: Gibraltar\"\n[25] \"Samoa\"                 \"Numbani\"               \"Dorado\"               \n\n$Mode\n[1] \"Assault\"       \"Attack Escort\" \"Robot\"         \"Attack\"       \n[5] \"Escort\"       \n\n$Role\n[1] \"Damage\"  \"Tank\"    \"Support\"\n\n$Elimination\n [1] 28 17 27  8 10  7 22 15 21 14 16 20  5 11 33 19 34 23  6 18  9 12 29 26  4\n[26] 13 58\n\n$Assists\n [1]  0  3  4  2  6  8  5  7 12 10 11 16  1 13 26 20 22 14 30  9 19 17 15 23 51\n\n$Deaths\n [1]  5  4  7  6  9  1  3 10  8 12  2  0 11\n\n$Damage\n [1] 11480  6713  5776  7138  2163  4416  7538 10948  9735  4102  7234  6301\n[13]  1166  4403  6042  8466  5083  4307  7841  2509  5076  9435  8793  6227\n[25] 13201  4548  7355  6344  2801 10388  4632 13538  8332 14824  2328  7634\n[37]  8196  3417  5347  3869  3395  5768  6849  3440  1886  3324  9540  2458\n[49]  7477  1755  4336  3506  2364  5320  3444  4283  3849  9577  3349  2520\n[61]  1844  2934  5021  1445  4768  2309  3290  2636  3812  2239  3100  2999\n[73]  2949  4437   773  2504  3032  3198  1015  1506  5172  4210  3694  1907\n[85]  3736  4602 12204\n\n$Heals\n [1]  2484     0   122     8  4849  2498  2260   225   382   941   129   187\n[13]    78  5917  1900    16  1542  1490  1342   243  1322  1185   543  2866\n[25]   731   734   330    63  7782   727  7352   241   722   536   822  7641\n[37]  9179  7375   942    21 12938  7404  4384  6813  6107 11855  4188  9333\n[49]  2738  1018  2832  3286  6780  5880  8181  4120 11971  1142  8902  2698\n[61]  4689  8910  8853  2510  4060 10032  3860  8015  9545 18620\n\n$Mitigation\n [1]    0  245 2082  828 1068 5654 6078 2012 4439  486 1386 1735 2692 3197 6532\n[16] 3251 5070 2760 1994  980 5243 3220 4639 5234 7253 1686  734 1275  928 3676\n[31] 1860  364  900  462 2472  220  548 2886 3901  598\n\n\n\n\n\n\n\n\nNote\n\n\n\nWe can access a column in a data.frame by using the $ operator. When we do this, we can treat the column as if it is a single vector.\n\n\nIf we analyze the output of the summary() and the str() function, we can see that the Date column is categorized as a character. Let’s reassign it’s class by using the as.Date function.\n\n\nhide code\n#' because the values of Date appear as MM/DD/YY in the data, we will use %m/%d/%y to follow the same format.\n#' %y represents year using 2 digits, %Y represents using 4 digits\n\now$Date &lt;- as.Date(ow$Date, format = \"%m/%d/%y\")\nclass(ow$Date)\n\n\n[1] \"Date\"",
    "crumbs": [
      "Introduction to Dataframes"
    ]
  },
  {
    "objectID": "05_Dataframes.html#visualizing-the-data",
    "href": "05_Dataframes.html#visualizing-the-data",
    "title": "Introduction to Dataframes",
    "section": "Visualizing the data",
    "text": "Visualizing the data\nThe output of summary() and str() told us that we have several numeric columns in our data: eliminations, assists, deaths, damage, heals, and mitigation.\nLet’s first visualize a histogram for the damage column to determine its distribution.\n\n\nhide code\n# using base R function: hist()\nhist(ow$Damage)\n\n\n\n\n\n\n\n\n\nWe can also create a boxplot as another way to view its distribution and determine what our potential outliers would look like.\n\n\nhide code\n# using base R function: boxplot()\nboxplot(ow$Damage)",
    "crumbs": [
      "Introduction to Dataframes"
    ]
  },
  {
    "objectID": "05_Dataframes.html#data-transformation",
    "href": "05_Dataframes.html#data-transformation",
    "title": "Introduction to Dataframes",
    "section": "Data Transformation",
    "text": "Data Transformation\n\nConvert the data.frame from wide to long\nTransformation Functions:\n\npivot_longer() -&gt; function to go from wide to long\npivot_wider() -&gt; function to go from long to wide\n\n\n\nhide code\now_long &lt;- ow %&gt;% pivot_longer(cols=c(\"Elimination\", \"Assists\",\n                                      \"Deaths\", \"Damage\", \"Heals\",\n                                      \"Mitigation\"), \n                                names_to = \"value_type\", \n                                values_to = \"value\")\n\nhead(ow_long)\n\n\n# A tibble: 6 × 8\n  Player  Date         Win Map      Mode    Role   value_type  value\n  &lt;chr&gt;   &lt;date&gt;     &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;       &lt;dbl&gt;\n1 player1 2024-08-15     1 Suravasa Assault Damage Elimination    28\n2 player1 2024-08-15     1 Suravasa Assault Damage Assists         0\n3 player1 2024-08-15     1 Suravasa Assault Damage Deaths          5\n4 player1 2024-08-15     1 Suravasa Assault Damage Damage      11480\n5 player1 2024-08-15     1 Suravasa Assault Damage Heals        2484\n6 player1 2024-08-15     1 Suravasa Assault Damage Mitigation      0\n\n\n\nConcepts to know:\n\n%&gt;% -&gt; pipe operator, takes the output of the expression of the LHS and passes it to the first argument on its RHS\n\n\nhide code\n#summary(ow)\n\n#ow %&gt;% summary()\n\now %&gt;%\n    head() %&gt;%\n      summary()\n\n\n    Player               Date                 Win             Map           \n Length:6           Min.   :2024-08-15   Min.   :0.0000   Length:6          \n Class :character   1st Qu.:2024-08-15   1st Qu.:0.2500   Class :character  \n Mode  :character   Median :2024-08-15   Median :1.0000   Mode  :character  \n                    Mean   :2024-08-15   Mean   :0.6667                     \n                    3rd Qu.:2024-08-15   3rd Qu.:1.0000                     \n                    Max.   :2024-08-15   Max.   :1.0000                     \n     Mode               Role            Elimination       Assists    \n Length:6           Length:6           Min.   : 7.00   Min.   :0.00  \n Class :character   Class :character   1st Qu.: 8.50   1st Qu.:2.25  \n Mode  :character   Mode  :character   Median :13.50   Median :3.00  \n                                       Mean   :16.17   Mean   :2.50  \n                                       3rd Qu.:24.50   3rd Qu.:3.00  \n                                       Max.   :28.00   Max.   :4.00  \n     Deaths          Damage          Heals          Mitigation     \n Min.   :4.000   Min.   : 2163   Min.   :   0.0   Min.   :   0.00  \n 1st Qu.:4.250   1st Qu.: 4756   1st Qu.:  36.5   1st Qu.:  61.25  \n Median :5.500   Median : 6244   Median :1303.0   Median : 536.50  \n Mean   :5.833   Mean   : 6281   Mean   :1660.2   Mean   : 703.83  \n 3rd Qu.:6.750   3rd Qu.: 7032   3rd Qu.:2494.5   3rd Qu.:1008.00  \n Max.   :9.000   Max.   :11480   Max.   :4849.0   Max.   :2082.00  \n\n\n\nThe example above states: with the overwatch dataset, use the function head() and from the output of head(), use the function summary().\n\n\n\nDplyr\ndplyr is a package in R that is part of tidyverse, it is the main package for data manipulation that is super intuitive. It is often described as “grammar for data manipulation”\n\nmutate() - adds new variables that are “manipulations” of other variables that already exist in your data / create or transform columns\n\n\nUsing mutate()\n\n\nhide code\ndf &lt;- data.frame(x=c(1,3,8,10, NA, 5, 6))\ndf &lt;- df %&gt;% \n  mutate(x2 = x^2)\nprint(df)\n\n\n   x  x2\n1  1   1\n2  3   9\n3  8  64\n4 10 100\n5 NA  NA\n6  5  25\n7  6  36\n\n\n\n\nfilter() - filters or picks cases based on their values\n\n\n\n\n\n\n\nTip\n\n\n\nThe filter() function will always return or filter your data for conditions that are TRUE meaning conditions that are FALSE or conditions that are NA will not be returned.\n\nIf you want to retain the missing values, you have to explicitly filter for it as well.\nUse is.na() to determine if value is missing.\n\n\n\nhide code\ndf &lt;- data.frame(x=c(1,3,8,10, NA, 5, 6))\n\n# NA is dropped as well\nfilter &lt;- df %&gt;% filter(x != 3)\nfilter\n\n\n   x\n1  1\n2  8\n3 10\n4  5\n5  6\n\n\nhide code\nfilter &lt;- df %&gt;% filter(x != 3 | is.na(x))\nfilter\n\n\n   x\n1  1\n2  8\n3 10\n4 NA\n5  5\n6  6\n\n\n\n\n\nselect() - picks based on columns/variables\narrange() - reorder rows\nsummarise() - collapse into specified summary statistics\ngroup_by() - allows functions to be conducted by group\n\n\n\n\n\n\n\nungroup()\n\n\n\nWhen you use group_by(), you should try your best to ungroup() your data afterwards so that any following operation is not done within groups again.\n\n\nhide code\ndf &lt;- data.frame(student = c(\"X\", \"X\", \"X\", \"Y\", \"Y\", \"Y\"), \n                         score = c(100, 98, 85, 90, 96, 98), \n                 class = c(\"Math\", \"Math\", \"Bio\", \"Bio\", \"Bio\", \"Math\"))\n\nmean_student &lt;- df %&gt;% \n            group_by(class, student) %&gt;%\n            summarise(average_score = mean(score))\n\n\n`summarise()` has grouped output by 'class'. You can override using the\n`.groups` argument.\n\n\nhide code\nprint(mean_student)\n\n\n# A tibble: 4 × 3\n# Groups:   class [2]\n  class student average_score\n  &lt;chr&gt; &lt;chr&gt;           &lt;dbl&gt;\n1 Bio   X                  85\n2 Bio   Y                  93\n3 Math  X                  99\n4 Math  Y                  98\n\n\nhide code\nmean_student &lt;- mean_student %&gt;% \n  summarise(sum_score = sum(average_score))\n\nprint(mean_student)\n\n\n# A tibble: 2 × 2\n  class sum_score\n  &lt;chr&gt;     &lt;dbl&gt;\n1 Bio         178\n2 Math        197\n\n\nsummarise() drops one level of grouping but the highest level is retained, as shown in the second operation. Running the same lines of code but including ungroup() will provide an overall_sum at the end, instead of a sum by class.\n\n\nhide code\nmean_student &lt;- df %&gt;% \n            group_by(class, student) %&gt;%\n            summarise(average_score = mean(score)) %&gt;%\n            ungroup()\n\n\n`summarise()` has grouped output by 'class'. You can override using the\n`.groups` argument.\n\n\nhide code\nprint(mean_student)\n\n\n# A tibble: 4 × 3\n  class student average_score\n  &lt;chr&gt; &lt;chr&gt;           &lt;dbl&gt;\n1 Bio   X                  85\n2 Bio   Y                  93\n3 Math  X                  99\n4 Math  Y                  98\n\n\nhide code\nmean_student &lt;- mean_student %&gt;% \n  summarise(sum_score = sum(average_score))\n\nprint(mean_student)\n\n\n# A tibble: 1 × 1\n  sum_score\n      &lt;dbl&gt;\n1       375\n\n\n\n\n\nWhat is the total number of wins and losses and percentage of wins/losses for each Player? By each Date? Create a visualization.\n\n\nhide code\n# create a new data.frame that is a copy of ow_long, group it by Player & Date, and use the summarise function to calculate the total number of wins/loses and its percent\nplayer_wins &lt;- ow_long %&gt;%\n  group_by(Player, Date) %&gt;%\n  summarise(wins = sum(Win),\n            pct_win = sum(Win)/n() * 100, \n            lose = n() - sum(Win), \n            pct_lose = lose/n() * 100)\n\n\n`summarise()` has grouped output by 'Player'. You can override using the\n`.groups` argument.\n\n\nhide code\nprint(player_wins)\n\n\n# A tibble: 10 × 6\n# Groups:   Player [2]\n   Player  Date        wins pct_win  lose pct_lose\n   &lt;chr&gt;   &lt;date&gt;     &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n 1 player1 2024-08-12    24    50      24     50  \n 2 player1 2024-08-13    78    68.4    36     31.6\n 3 player1 2024-08-14    66    73.3    24     26.7\n 4 player1 2024-08-15    48    66.7    24     33.3\n 5 player1 2024-08-16     6    50       6     50  \n 6 player2 2024-08-10     6    50       6     50  \n 7 player2 2024-08-13    60    83.3    12     16.7\n 8 player2 2024-08-14     6   100       0      0  \n 9 player2 2024-08-15    36    75      12     25  \n10 player2 2024-08-17    12    25      36     75  \n\n\nCreate a bar-graph:\n\n\nhide code\n# plotting number of wins\nbar &lt;- ggplot(data = player_wins, aes(x= Date, y= wins)) + \n  geom_bar(aes(fill = Player), position=\"dodge\", stat=\"identity\")\n\nprint(bar)\n\n\n\n\n\n\n\n\n\nCreate a line-graph:\n\n\nhide code\nline &lt;- ggplot(data = player_wins, aes(x= Date, y= wins)) +\n  geom_line(aes(color = Player)) + geom_point()\nprint(line)\n\n\n\n\n\n\n\n\n\n\n\nWhat is the total number of eliminations and damage by Role? Create a visualization.\n\n\nhide code\nrole_stats &lt;- ow_long %&gt;% \n  group_by(Player, Role, value_type) %&gt;%\n  summarise(sum_val = sum(value))\n\n\n`summarise()` has grouped output by 'Player', 'Role'. You can override using\nthe `.groups` argument.\n\n\nhide code\nhead(role_stats)\n\n\n# A tibble: 6 × 4\n# Groups:   Player, Role [1]\n  Player  Role   value_type  sum_val\n  &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;         &lt;dbl&gt;\n1 player1 Damage Assists          61\n2 player1 Damage Damage       139972\n3 player1 Damage Deaths          130\n4 player1 Damage Elimination     415\n5 player1 Damage Heals         14135\n6 player1 Damage Mitigation    12348\n\n\nhide code\nprint(role_stats %&gt;% filter(value_type %in% c(\"Elimination\", \"Damage\")))\n\n\n# A tibble: 12 × 4\n# Groups:   Player, Role [6]\n   Player  Role    value_type  sum_val\n   &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt;\n 1 player1 Damage  Damage       139972\n 2 player1 Damage  Elimination     415\n 3 player1 Support Damage        35623\n 4 player1 Support Elimination     122\n 5 player1 Tank    Damage       163196\n 6 player1 Tank    Elimination     401\n 7 player2 Damage  Damage         2934\n 8 player2 Damage  Elimination       7\n 9 player2 Support Damage        87308\n10 player2 Support Elimination     435\n11 player2 Tank    Damage        20389\n12 player2 Tank    Elimination      71\n\n\nhide code\nchart &lt;- ggplot(data = role_stats, aes(x = Role, y = sum_val)) +\n  geom_bar(position = \"dodge\", stat = \"identity\", aes(fill = Player)) +\n  facet_wrap(~ value_type, scales = \"free_y\")\nprint(chart)\n\n\n\n\n\n\n\n\n\nWe can also re-order the way our items appear in our chart by making our ordering variables factors and setting its levels. Below, we set Role and value_type to be a factor where the levels are in the order we want these categories to appear on our chart (the x-axis for Role and the various facets for value_type).\n\n\nhide code\n# re-order the x-axis by changing Role into a factor with wanted order of levels\n# Tank, Support, Damage \n\nrole_stats$Role &lt;- factor(role_stats$Role, levels=c(\"Tank\", \"Support\", \"Damage\"))\nunique(role_stats$Role)\n\n\n[1] Damage  Support Tank   \nLevels: Tank Support Damage\n\n\nhide code\nrole_stats$value_type &lt;- factor(role_stats$value_type, levels = c(\"Elimination\", \n                                                                  \"Assists\", \n                                                                  \"Deaths\", \n                                                                  \"Damage\",\n                                                                  \"Heals\",\n                                                                  \"Mitigation\"))\nunique(role_stats$value_type)\n\n\n[1] Assists     Damage      Deaths      Elimination Heals       Mitigation \nLevels: Elimination Assists Deaths Damage Heals Mitigation\n\n\nRe-define the plot:\n\n\nhide code\nchart &lt;- ggplot(data = role_stats, aes(x = Role, y = sum_val)) +\n  geom_bar(position = \"dodge\", stat = \"identity\", aes(fill = Player)) +\n  facet_wrap(~ value_type, scales = \"free_y\")\nprint(chart)",
    "crumbs": [
      "Introduction to Dataframes"
    ]
  },
  {
    "objectID": "05_Dataframes.html#dplyr",
    "href": "05_Dataframes.html#dplyr",
    "title": "Introduction to Dataframes",
    "section": "Dplyr",
    "text": "Dplyr\ndplyr is a package in R that is part of tidyverse, it is the main package for data manipulation that is super intuitive. It is often described as “grammar for data manipulation”\n\nmutate() - adds new variables that are “manipulations” of other variables that already exist in your data / create or transform columns\nfilter() - filters or picks cases based on their values\nselect() - picks based on columns/variables\narrange() - reorder rows\nsummarise() - collapse into specified summary statistics\ngroup_by() - allows functions to be conducted by group\n\n\nWhat is the total number of wins and losses and percentage of wins/losses for each Player? By each Date? Create a visualization.\n\n\nhide code\n# create a new data.frame that is a copy of ow_long, group it by Player & Date, and use the summarise function to calculate the total number of wins/loses and its percent\nplayer_wins &lt;- ow_long %&gt;%\n  group_by(Player, Date) %&gt;%\n  summarise(wins = sum(Win),\n            pct_win = sum(Win)/n() * 100, \n            lose = n() - sum(Win), \n            pct_lose = lose/n() * 100)\n\n\n`summarise()` has grouped output by 'Player'. You can override using the\n`.groups` argument.\n\n\nhide code\nprint(player_wins)\n\n\n# A tibble: 10 × 6\n# Groups:   Player [2]\n   Player  Date        wins pct_win  lose pct_lose\n   &lt;chr&gt;   &lt;date&gt;     &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n 1 player1 2024-08-12    24    50      24     50  \n 2 player1 2024-08-13    78    68.4    36     31.6\n 3 player1 2024-08-14    66    73.3    24     26.7\n 4 player1 2024-08-15    48    66.7    24     33.3\n 5 player1 2024-08-16     6    50       6     50  \n 6 player2 2024-08-10     6    50       6     50  \n 7 player2 2024-08-13    60    83.3    12     16.7\n 8 player2 2024-08-14     6   100       0      0  \n 9 player2 2024-08-15    36    75      12     25  \n10 player2 2024-08-17    12    25      36     75  \n\n\nCreate a bar-graph:\n\n\nhide code\n# plotting number of wins\nbar &lt;- ggplot(data = player_wins, aes(x= Date, y= wins)) + \n  geom_bar(aes(fill = Player), position=\"dodge\", stat=\"identity\")\n\nprint(bar)\n\n\n\n\n\n\n\n\n\nCreate a line-graph:\n\n\nhide code\nline &lt;- ggplot(data = player_wins, aes(x= Date, y= wins)) +\n  geom_line(aes(color = Player)) + geom_point()\nprint(line)\n\n\n\n\n\n\n\n\n\n\n\nWhat is the total number of eliminations and damage by Role? Create a visualization.\n\n\nhide code\nrole_stats &lt;- ow_long %&gt;% \n  group_by(Player, Role, value_type) %&gt;%\n  summarise(sum_val = sum(value))\n\n\n`summarise()` has grouped output by 'Player', 'Role'. You can override using\nthe `.groups` argument.\n\n\nhide code\nhead(role_stats)\n\n\n# A tibble: 6 × 4\n# Groups:   Player, Role [1]\n  Player  Role   value_type  sum_val\n  &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;         &lt;dbl&gt;\n1 player1 Damage Assists          61\n2 player1 Damage Damage       139972\n3 player1 Damage Deaths          130\n4 player1 Damage Elimination     415\n5 player1 Damage Heals         14135\n6 player1 Damage Mitigation    12348\n\n\nhide code\nprint(role_stats %&gt;% filter(value_type %in% c(\"Elimination\", \"Damage\")))\n\n\n# A tibble: 12 × 4\n# Groups:   Player, Role [6]\n   Player  Role    value_type  sum_val\n   &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt;\n 1 player1 Damage  Damage       139972\n 2 player1 Damage  Elimination     415\n 3 player1 Support Damage        35623\n 4 player1 Support Elimination     122\n 5 player1 Tank    Damage       163196\n 6 player1 Tank    Elimination     401\n 7 player2 Damage  Damage         2934\n 8 player2 Damage  Elimination       7\n 9 player2 Support Damage        87308\n10 player2 Support Elimination     435\n11 player2 Tank    Damage        20389\n12 player2 Tank    Elimination      71\n\n\nhide code\nchart &lt;- ggplot(data = role_stats, aes(x = Role, y = sum_val)) +\n  geom_bar(position = \"dodge\", stat = \"identity\", aes(fill = Player)) +\n  facet_wrap(~ value_type, scales = \"free_y\")\nprint(chart)\n\n\n\n\n\n\n\n\n\nWe can also re-order the way our items appear in our chart by making our ordering variables factors and setting its levels. Below, we set Role and value_type to be a factor where the levels are in the order we want these categories to appear on our chart (the x-axis for Role and the various facets for value_type).\n\n\nhide code\n# re-order the x-axis by changing Role into a factor with wanted order of levels\n# Tank, Support, Damage \n\nrole_stats$Role &lt;- factor(role_stats$Role, levels=c(\"Tank\", \"Support\", \"Damage\"))\nunique(role_stats$Role)\n\n\n[1] Damage  Support Tank   \nLevels: Tank Support Damage\n\n\nhide code\nrole_stats$value_type &lt;- factor(role_stats$value_type, levels = c(\"Elimination\", \n                                                                  \"Assists\", \n                                                                  \"Deaths\", \n                                                                  \"Damage\",\n                                                                  \"Heals\",\n                                                                  \"Mitigation\"))\nunique(role_stats$value_type)\n\n\n[1] Assists     Damage      Deaths      Elimination Heals       Mitigation \nLevels: Elimination Assists Deaths Damage Heals Mitigation\n\n\nRe-define the plot:\n\n\nhide code\nchart &lt;- ggplot(data = role_stats, aes(x = Role, y = sum_val)) +\n  geom_bar(position = \"dodge\", stat = \"identity\", aes(fill = Player)) +\n  facet_wrap(~ value_type, scales = \"free_y\")\nprint(chart)",
    "crumbs": [
      "Introduction to Dataframes"
    ]
  },
  {
    "objectID": "05_Dataframes.html#merging",
    "href": "05_Dataframes.html#merging",
    "title": "Introduction to Dataframes",
    "section": "Merging",
    "text": "Merging\n\nRecall: Merging data sets is the process of combining two or more data sets based on common columns or row indices. This is common in data analytics when you need to bring information together from different sources into one single data set.\n\n\nJoin Functions\n\n\n\n\n\n\nJoin Types\n\n\n\n\n\n\n\n\n\n\n\nJoin Function\nDescription\n\n\n\n\n\ninner_join()\nKeeps only rows that have a match in both datasets.\nOverlap only\n\n\nleft_join()\nKeeps all rows from the left dataset, filling with NA if no match on right.\nKeep the left side\n\n\nright_join()\nKeeps all rows from the right dataset, filling with NA if no match on left.\nKeep the right side\n\n\nfull_join()\nKeeps all rows from both datasets; matches are combined, non-matches get NA.\nKeep everything\n\n\nsemi_join()\nFilters the left dataset to only rows that have a match in the right; doesn’t add columns.\nLeft rows with matches\n\n\nanti_join()\nFilters the left dataset to rows that do not have a match in the right.\nLeft rows without matches\n\n\n\n\n\nTo further analyze our data, we will merge the overwatch_heros.csv into our current data.frame.In addition to the Overwatch dataset, the accompanying dataset (overwatch_heros) lists the heroes played in each game. We know that each row in the original Overwatch dataset we’ve been working with corresponds to a single game. Because of the game’s mechanics, players are allowed to switch heroes during a match. As a result, in the heroes dataset, you’ll see that a player may have played multiple heroes within the same game.\n\nThe overwatch_heros data set contains these attributes:\n\nPlayer\nDate\nWin\nMap\nMode\nRole\nPercent Played\nHero\n\n\n\n\nhide code\n# read in the new data set\ndir &lt;- \"/Users/rdominguez/Documents/MA500/Lessons/datasets/\"\n\nhero &lt;- read_csv(paste0(dir, \"overwatch_heros.csv\"))\n\n\nRows: 99 Columns: 8\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (6): Player, Date, Map, Mode, Role, Hero\ndbl (2): Win, Percent Played\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nhide code\nstr(hero)\n\n\nspc_tbl_ [99 × 8] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ Player        : chr [1:99] \"player1\" \"player1\" \"player1\" \"player1\" ...\n $ Date          : chr [1:99] \"8/15/24\" \"8/15/24\" \"8/15/24\" \"8/15/24\" ...\n $ Win           : num [1:99] 1 1 1 0 0 1 1 0 0 1 ...\n $ Map           : chr [1:99] \"Suravasa\" \"Suravasa\" \"King's Row\" \"New Queen Street\" ...\n $ Mode          : chr [1:99] \"Assault\" \"Assault\" \"Attack Escort\" \"Robot\" ...\n $ Role          : chr [1:99] \"Damage\" \"Damage\" \"Damage\" \"Tank\" ...\n $ Percent Played: num [1:99] 82 18 100 100 100 100 100 48 52 100 ...\n $ Hero          : chr [1:99] \"Sombra\" \"Bastion\" \"Sombra\" \"Dva\" ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   Player = col_character(),\n  ..   Date = col_character(),\n  ..   Win = col_double(),\n  ..   Map = col_character(),\n  ..   Mode = col_character(),\n  ..   Role = col_character(),\n  ..   `Percent Played` = col_double(),\n  ..   Hero = col_character()\n  .. )\n - attr(*, \"problems\")=&lt;externalptr&gt; \n\n\nhide code\n# set the Date column as a Date data type\nhero$Date &lt;- as.Date(hero$Date, format = \"%m/%d/%y\")\nclass(hero$Date)\n\n\n[1] \"Date\"\n\n\nThe output of str() shows that the hero data frame contains more observations than the Overwatch dataset, which has 87 entries.\nWhen you use the left_join function to merge the ow data frame with the hero data frame, it will match all key values from the hero data to the ow data. However, the first time you run this, you’ll encounter a “many-to-many relationship” warning. This means that the join will occur, but it will generate all possible combinations of our key columns—Player, Date, Win, Map, Mode, and Role—with the various corresponding heroes.\nTo simplify things, we’ll only join the rows associated with the heroes that were played the most during each game.\n\n\nhide code\nhero_most_played &lt;- hero %&gt;%\n  group_by(Player, Date, Win, Map, Mode, Role) %&gt;%\n  filter(`Percent Played` == max(`Percent Played`))\n\now_with_hero &lt;- left_join(ow, hero_most_played, by=\n                            c(\"Player\", \"Date\", \"Win\",\n                              \"Map\", \"Mode\", \"Role\"))\n\n\nWarning in left_join(ow, hero_most_played, by = c(\"Player\", \"Date\", \"Win\", : Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 24 of `x` matches multiple rows in `y`.\nℹ Row 24 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\nWhen merging, you may encounter a “many-to-many relationship” warning. This occurs because there are duplicate combinations of our key indicators: Player, Date, Win, Map, Mode, Role. In other words, the dataset contains multiple games played by the same player, on the same date, with the same result, on the same map, mode, and role. Normally, this issue would be prevented by assigning a unique game identifier. However, this dataset does not include such an identifier. As a result, a player can appear in several games on the same day—even under the exact same conditions (map, role, and mode).\nTo move forward with analysis, we will detect and remove these duplicate entries to ensure clean merges.\n\ntldr: issue 1 with the merge: The dataset lacks a unique game identifier, which causes duplicate entries.\n\n\n\nhide code\n# this code counts all possible combinations of our key indicators and filters to the set that shows up more than once\nduplicate &lt;- ow %&gt;% \n  count(Player, Date, Win, Map, Mode, Role) %&gt;%\n  filter(n &gt; 1)\nprint(duplicate)\n\n\n# A tibble: 1 × 7\n  Player  Date         Win Map      Mode    Role       n\n  &lt;chr&gt;   &lt;date&gt;     &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;   &lt;chr&gt;  &lt;int&gt;\n1 player1 2024-08-13     1 Suravasa Assault Damage     2\n\n\nAfter we find this duplicate combination of our key indicators, we will remove it from our ow_with_hero data.frame and move on with our analysis. This will be done using anti_join.\n\n\nhide code\now_with_hero &lt;- ow_with_hero %&gt;%\n    anti_join(duplicate, by = c(\"Player\", \"Date\", \"Win\", \"Map\",\n        \"Mode\", \"Role\"))\n\n\n\nAnalyze player 2’s statistics by their Heroes played.\nFirst, let’s transform our newly merged data from wide to long for easier analysis.\n\n\nhide code\now_long_with_hero &lt;- ow_with_hero %&gt;% pivot_longer(cols=c(\"Elimination\", \"Assists\",\n                                      \"Deaths\", \"Damage\", \"Heals\",\n                                      \"Mitigation\"), \n                                names_to = \"value_type\", \n                                values_to = \"value\")\n\n\nNext, we are going to create a new dataset that only contains Player 2’s records and summarize from there.\n\n\nhide code\nplayer2 &lt;- ow_long_with_hero %&gt;%\n  filter(Player == \"player2\") %&gt;%\n  group_by(Player, Hero, value_type) %&gt;%\n  summarise(sum_val = sum(value))\n\n\n`summarise()` has grouped output by 'Player', 'Hero'. You can override using\nthe `.groups` argument.\n\n\nhide code\nprint(player2)\n\n\n# A tibble: 30 × 4\n# Groups:   Player, Hero [5]\n   Player  Hero       value_type  sum_val\n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;         &lt;dbl&gt;\n 1 player2 Lifeweaver Assists          17\n 2 player2 Lifeweaver Damage         2239\n 3 player2 Lifeweaver Deaths            3\n 4 player2 Lifeweaver Elimination      11\n 5 player2 Lifeweaver Heals          8181\n 6 player2 Lifeweaver Mitigation        0\n 7 player2 Mauga      Assists          17\n 8 player2 Mauga      Damage        10449\n 9 player2 Mauga      Deaths           16\n10 player2 Mauga      Elimination      44\n# ℹ 20 more rows\n\n\nLet’s just create another bar-chart to visualize these results!\n\n\nhide code\np2_facet &lt;- ggplot(data = player2, aes(x=Hero, y=sum_val))+\n  geom_bar(stat = \"identity\")+facet_wrap(~value_type, scales=\"free_y\")\nprint(p2_facet)",
    "crumbs": [
      "Introduction to Dataframes"
    ]
  },
  {
    "objectID": "05_Dataframes.html#what-is-the-total-number-of-eliminations-and-damage-by-role-create-a-visualization.",
    "href": "05_Dataframes.html#what-is-the-total-number-of-eliminations-and-damage-by-role-create-a-visualization.",
    "title": "Introduction to Dataframes",
    "section": "What is the total number of eliminations and damage by Role? Create a visualization.",
    "text": "What is the total number of eliminations and damage by Role? Create a visualization.\n\n\nhide code\nrole_stats &lt;- ow_long %&gt;% \n  group_by(Player, Role, value_type) %&gt;%\n  summarise(sum_val = sum(value))\n\n\n`summarise()` has grouped output by 'Player', 'Role'. You can override using\nthe `.groups` argument.\n\n\nhide code\nhead(role_stats)\n\n\n# A tibble: 6 × 4\n# Groups:   Player, Role [1]\n  Player  Role   value_type  sum_val\n  &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;         &lt;dbl&gt;\n1 player1 Damage Assists          61\n2 player1 Damage Damage       139972\n3 player1 Damage Deaths          130\n4 player1 Damage Elimination     415\n5 player1 Damage Heals         14135\n6 player1 Damage Mitigation    12348\n\n\nhide code\nprint(role_stats %&gt;% filter(value_type %in% c(\"Elimination\", \"Damage\")))\n\n\n# A tibble: 12 × 4\n# Groups:   Player, Role [6]\n   Player  Role    value_type  sum_val\n   &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt;\n 1 player1 Damage  Damage       139972\n 2 player1 Damage  Elimination     415\n 3 player1 Support Damage        35623\n 4 player1 Support Elimination     122\n 5 player1 Tank    Damage       163196\n 6 player1 Tank    Elimination     401\n 7 player2 Damage  Damage         2934\n 8 player2 Damage  Elimination       7\n 9 player2 Support Damage        87308\n10 player2 Support Elimination     435\n11 player2 Tank    Damage        20389\n12 player2 Tank    Elimination      71\n\n\nhide code\nchart &lt;- ggplot(data = role_stats, aes(x = Role, y = sum_val)) +\n  geom_bar(position = \"dodge\", stat = \"identity\", aes(fill = Player)) +\n  facet_wrap(~ value_type, scales = \"free_y\")\nprint(chart)\n\n\n\n\n\n\n\n\n\nWe can also re-order the way our items appear in our chart by making our ordering variables factors and setting its levels. Below, we set Role and value_type to be a factor where the levels are in the order we want these categories to appear on our chart (the x-axis for Role and the various facets for value_type).\n\n\nhide code\n# re-order the x-axis by changing Role into a factor with wanted order of levels\n# Tank, Support, Damage \n\nrole_stats$Role &lt;- factor(role_stats$Role, levels=c(\"Tank\", \"Support\", \"Damage\"))\nunique(role_stats$Role)\n\n\n[1] Damage  Support Tank   \nLevels: Tank Support Damage\n\n\nhide code\nrole_stats$value_type &lt;- factor(role_stats$value_type, levels = c(\"Elimination\", \n                                                                  \"Assists\", \n                                                                  \"Deaths\", \n                                                                  \"Damage\",\n                                                                  \"Heals\",\n                                                                  \"Mitigation\"))\nunique(role_stats$value_type)\n\n\n[1] Assists     Damage      Deaths      Elimination Heals       Mitigation \nLevels: Elimination Assists Deaths Damage Heals Mitigation\n\n\nRe-define the plot:\n\n\nhide code\nchart &lt;- ggplot(data = role_stats, aes(x = Role, y = sum_val)) +\n  geom_bar(position = \"dodge\", stat = \"identity\", aes(fill = Player)) +\n  facet_wrap(~ value_type, scales = \"free_y\")\nprint(chart)",
    "crumbs": [
      "Introduction to Dataframes"
    ]
  },
  {
    "objectID": "06_Visualizations.html",
    "href": "06_Visualizations.html",
    "title": "Data Visualizations",
    "section": "",
    "text": "ggplot2 components\nA ggplot is comprised of 1. data, 2. aesthetic mappings, and 3. geometries (the type of plot you would like to graph).\nBeyond the bar charts and line graphs discussed in the previous section, ggplot2 offers a variety of other visualizations that you can create. We’ll be using the mtcars dataset, which is readily available in your R environment, to explore these options.\nhide code\nlibrary(ggplot2)\ndata(mtcars)\nhead(mtcars)\n\n\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1",
    "crumbs": [
      "Data Visualizations"
    ]
  },
  {
    "objectID": "06_Visualizations.html#types-of-plots",
    "href": "06_Visualizations.html#types-of-plots",
    "title": "Data Visualizations",
    "section": "Types of Plots",
    "text": "Types of Plots\n\nScatter Plot\n\nShows relationship between two continuous variables\n\n\n\nhide code\nscatter &lt;- ggplot(data = mtcars, \n                  aes(x = wt, y = mpg))+\n  geom_point()+\n  labs(x = \"Weight\",\n       y = \"Miles per Gallon\")\nprint(scatter)\n\n\n\n\n\n\n\n\n\n\n\nLine Plot\n\nDisplays trends over time or ordered data\n\n\n\nhide code\nline &lt;- ggplot(mtcars, aes(x = hp, y = mpg)) +\n  geom_line() +\n  labs(x = \"Horsepower\",\n       y = \"Miles Per Gallon\")\nprint(line)\n\n\n\n\n\n\n\n\n\nhide code\n# if you want to plot the trend of the different\n# values in a categorical variable, you can \n# set it as a color \nline &lt;- ggplot(mtcars, aes(x = hp, y = mpg)) +\n  geom_line(aes(color = factor(gear))) +\n  labs(x = \"Horsepower\",\n       y = \"Miles Per Gallon\", \n       color = \"Number of Gear\")\nprint(line)\n\n\n\n\n\n\n\n\n\n\n\nBar Plot\n\nDisplays counts or summary statistics of categorical data\n\n\n\nhide code\nbar &lt;- ggplot(mtcars, aes(x = factor(cyl))) +\n  geom_bar(fill = \"steelblue\") +\n  labs(x = \"Number of Cylinders\",\n       y = \"Count\")\nprint(bar)\n\n\n\n\n\n\n\n\n\n\n\nHistogram\n\nDisplays the distribution of a single continuous variable\n\n\n\nhide code\nhist &lt;- ggplot(mtcars, aes(x = mpg)) +\n  geom_histogram(binwidth = 2, fill = \"steelblue\") +\n  labs(title = \"Histogram of MPG\",\n       x = \"Miles Per Gallon\",\n       y = \"Frequency\")\nprint(hist)\n\n\n\n\n\n\n\n\n\n\n\nBoxplot\n\nDisplays the distribution of one or multiple continuous variables\n\n\n\nhide code\n# you can fill/color the boxes to correspond to a # specific categorical variable as well \nbox &lt;- ggplot(mtcars, aes(x = factor(cyl), y = mpg)) +\n  geom_boxplot(aes(fill = factor(cyl))) +\n  labs(title = \"Box Plot of MPG by Cylinder\",\n       x = \"Number of Cylinders\",\n       y = \"Miles Per Gallon\", \n       fill = \"Number of Cylinders\")\nprint(box)\n\n\n\n\n\n\n\n\n\n\n\nDensity Plot\n\nDisplays the distribution as a smoothed curve of a continuous variable\nalpha: controls the transparency of the fill color.\n\n\n\nhide code\ndensity &lt;- ggplot(mtcars, aes(x = mpg)) +\n  geom_density(fill = \"blue\", alpha = 0.5) +\n  labs(x = \"Miles Per Gallon\",\n       y = \"Density\")\nprint(density)\n\n\n\n\n\n\n\n\n\n\n\nViolin Plot\n\nTo show the distribution of a continuous variable by categories (the factor variable), combining aspects of a box plot and a density plot.\n\n\n\nhide code\nviolin &lt;- ggplot(mtcars, aes(x = factor(cyl), y = mpg)) +\n  geom_violin(aes(fill = factor(cyl))) +\n  labs(x = \"Number of Cylinders\",\n       y = \"Miles Per Gallon\", \n       fill = \"Number of Cylinders\")\nprint(violin)\n\n\n\n\n\n\n\n\n\n\n\nFaceted Plots\n\nCreates multiple plots based on the values of a categorical variable\n\n\n\nhide code\nfacet &lt;- ggplot(mtcars, aes(x = wt, y = mpg)) +\n  geom_point(aes(color = factor(cyl))) +\n  facet_wrap(~ cyl) +\n  labs(x = \"Weight\",\n       y = \"Miles Per Gallon (mpg)\", \n       color = \"Number of Cylinders\")\nprint(facet)",
    "crumbs": [
      "Data Visualizations"
    ]
  },
  {
    "objectID": "06_Visualizations.html#themes",
    "href": "06_Visualizations.html#themes",
    "title": "Data Visualizations",
    "section": "Themes",
    "text": "Themes\nggplot2offers a variety of built-in themes that you can apply to change the appearance of your plots. Here are a few options you can use:\n\ntheme_grey()\ntheme_bw()\ntheme_linedraw()\ntheme_light()\ntheme_dark()\ntheme_minimal()\ntheme_classic()\ntheme_void()\n\nHere is how you can implement:\n\n\nhide code\n# re-using the box plot, we can append a new\n# ggplot element to our variable box\n\nbox &lt;- box + theme_minimal()\nprint(box)",
    "crumbs": [
      "Data Visualizations"
    ]
  },
  {
    "objectID": "06_Visualizations.html#additional-customization",
    "href": "06_Visualizations.html#additional-customization",
    "title": "Data Visualizations",
    "section": "Additional Customization",
    "text": "Additional Customization\n\nCase Study: Airquality Dataset\nTo discuss more on how to implement further customization of your visualizations with ggplot2, we will be using the built-in R dataset airquality.\n\n\nhide code\nlibrary(tidyverse)\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ lubridate 1.9.3     ✔ tibble    3.2.1\n✔ purrr     1.0.2     ✔ tidyr     1.3.1\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nhide code\nair &lt;- airquality\nsummary(air)\n\n\n     Ozone           Solar.R           Wind             Temp      \n Min.   :  1.00   Min.   :  7.0   Min.   : 1.700   Min.   :56.00  \n 1st Qu.: 18.00   1st Qu.:115.8   1st Qu.: 7.400   1st Qu.:72.00  \n Median : 31.50   Median :205.0   Median : 9.700   Median :79.00  \n Mean   : 42.13   Mean   :185.9   Mean   : 9.958   Mean   :77.88  \n 3rd Qu.: 63.25   3rd Qu.:258.8   3rd Qu.:11.500   3rd Qu.:85.00  \n Max.   :168.00   Max.   :334.0   Max.   :20.700   Max.   :97.00  \n NA's   :37       NA's   :7                                       \n     Month            Day      \n Min.   :5.000   Min.   : 1.0  \n 1st Qu.:6.000   1st Qu.: 8.0  \n Median :7.000   Median :16.0  \n Mean   :6.993   Mean   :15.8  \n 3rd Qu.:8.000   3rd Qu.:23.0  \n Max.   :9.000   Max.   :31.0  \n                               \n\n\nThe summary of our air dataset shows that it has 6 different variables, 4 continuous and 2 representing time. Let’s set labels and factor our Month column so that it represents the named Month instead of the numeric Month. With factor(), we can set labels onto our levels so when defining our labels, it will automatically map to the order of its current level.\n\n\nhide code\nair$Month &lt;- factor(air$Month, labels = c(\"May\", \"June\", \"July\", \"August\",\n                               \"September\"))\n\n\nWe will be creating three distinct plots, encoding the ‘Month’ variable through the use of color. To visually represent time, we’ll employ a gradient of blue shades, with lighter blues indicating earlier months and darker blues representing later months. We will also ensure that all 3 plots utilize the same color gradient.\n\n\nhide code\n# create a vector that establishes our colors for each month \nmonths &lt;- c(\"May\", \"June\", \"July\", \"August\", \"September\")\ncols   &lt;- c(\"#CAF0F8\", \"#90E0EF\", \"#00B4D8\",\n          \"#0077B6\", \"#03045E\")\n\nnames(cols) &lt;- months\n\n\nOur first plot, we will visualize the distribution of Temp by Month. This will help us visualize the differences in temperature by month.\n\n\nhide code\ng1 &lt;- ggplot(data = air, aes(x=Temp, fill=Month))+\n  geom_density(alpha = 0.7)+\n  scale_fill_manual(name = \"Months\", values=cols)+\n  theme(axis.text.x = element_text(size = 14), \n        axis.text.y = element_text(size = 14), \n        axis.title.x = element_text(size = 20), \n        axis.title.y = element_text(size = 20))\nprint(g1)\n\n\n\n\n\n\n\n\n\n\nThe scale_fill_manual() element of our ggplot ensures that the Months are colored by what we defined in the cols vector.\nWithin our theme() element, we are increasing the font size for the x-axis ticks (axis.text.x), x-axis title (axis.title.x), y-axis ticks (axis.text.y), and y-axis title (axis.title.y).\n\nIn our second plot, we will visualize the temperature trends by day. Additionally, we’ll incorporate wind speed as another variable. Given that wind speed is a continuous variable, we will represent it by varying the size of our data points—smaller points for lower wind speeds and larger points for higher speeds.\n\n\nhide code\ng2 &lt;- ggplot(data = air, aes(x = 1:nrow(air), y=Temp))+\n  geom_line(aes(col = Month))+\n  geom_point(aes(col = Month, size = Wind))+\n  geom_smooth(method = \"loess\", col=\"black\")+\n  scale_color_manual(name = \"Months\", values=cols)+\n  geom_vline(xintercept=c(31, 61, 92, 123, 153), linetype=\"dashed\")+guides(color=\"none\")+\n  labs(x=\"Day\")\nprint(g2)\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nFor this plot above, x is defined as 1:nrow(air)– the column Day in the air dataset corresponds to each month, however, since our dataset is ordered, the indices represent the true number of days.\n\nThe geom_point() element contains the argument size where we defined it to be Wind. ggplot will automatically determine what breakpoints are good to split these values/sizes up in.\nThe scale_color_manual() function ensures month is represented in the colors we discussed previously. Here, we used scale_color_manual instead of scale_fill_manual since our aesthetic for the points and line is a color rather than a fill.\ngeom_vline() allows you to add in vertical lines throughout the plot when provided an x-intercept. In our case, 31,61,92,123, and 153 represent the indices of our last days of the month.\nguides(color=\"none\") removes color from our legend, which will be useful later.\n\nOur third plot will represent the relationship between Wind and Temp, but also including Ozone into the plot by using size to represent its value. However, in this plot, we would also like to label datapoints that represent the max temperature for each month.\nGiven that we’re incorporating Ozone into this plot, I will eliminate any NAs from the dataframe. Initially, I considered recoding these as 0, but since the Ozone column represents the average ozone in parts per billion, a zero value could mistakenly indicate an actual measurement.\n\n\nhide code\nair_remove &lt;- air %&gt;% filter(Ozone != (is.na(Ozone)))\n\n\nNext, we are going to find the max temperatures by each year.\n\n\nhide code\nmax_temp &lt;- air %&gt;% group_by(Month) %&gt;%\n  filter(Temp == max(Temp))\n\n\n\n\nhide code\ng3 &lt;- ggplot(data = air, aes(x=Wind, y=Temp))+\n  geom_point(aes(size=Ozone, color=Month))+\n  geom_smooth(method=\"lm\", alpha = 0.2, aes(color = Month))+\n  geom_text(data = max_temp, aes(label = Temp), vjust=-1, hjust=0.5)+\n  scale_color_manual(name = \"Months\", values=cols)+\n  guides(color=\"none\")+theme_minimal()\nprint(g3)\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 37 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\n\n\n\nThe geom_text() element enables us to annotate the plot with maximum temperatures. We can create a dedicated dataset for it to process. By supplying only the max_temp dataframe, it will exclusively display the values contained within that dataset.",
    "crumbs": [
      "Data Visualizations"
    ]
  },
  {
    "objectID": "07_EDA.html",
    "href": "07_EDA.html",
    "title": "Exploratory Data Analysis",
    "section": "",
    "text": "Measures of Central Tendency\nExploratory Data Analysis (EDA) is the process of systematically examining your data to determine how best to visualize, summarize, and transform it in order to uncover patterns, trends, and insights. We use this process to:\nFor this process, we will be exploring the mtcars dataset. R has many built-in datasets and mtcars is one of them. You can bring up the documentation of the dataset by running ?mtcars. We can save it to our environment by running:\nMeasures of central tendency describes the center or typical values in your data set. We know a few already such as:\nThe above have functions in R, but for mode(), we can find it in different ways such as using the table() function or creating our own function.\nhide code\ntable(mtcars$cyl)\n\n\n\n 4  6  8 \n11  7 14\nOR\nhide code\nmode &lt;- function(x) {\n  names(sort(-table(x)))[1]\n}\n\nmode(mtcars$cyl)\n\n\n[1] \"8\"",
    "crumbs": [
      "Exploratory Data Analysis"
    ]
  },
  {
    "objectID": "07_EDA.html#measures-of-central-tendency",
    "href": "07_EDA.html#measures-of-central-tendency",
    "title": "Exploratory Data Analysis",
    "section": "",
    "text": "mean()\nmedian()\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\nClose mean and median values can show symmetry in your data.\nA higher or lower mean from the median can show skewness.",
    "crumbs": [
      "Exploratory Data Analysis"
    ]
  },
  {
    "objectID": "07_EDA.html#variation",
    "href": "07_EDA.html#variation",
    "title": "Exploratory Data Analysis",
    "section": "Variation",
    "text": "Variation\nVariation helps us determine the spread or how dispersed our data is. You can think of it as a way to determine “how consistent” your values are close to your “typical” or “centered” values.\nCommon functions include:\n\nrange()\nvar()\nsd()\nIQR()\n\nIt is beneficial to visualize your data distribution on top of computing these metrics above.\n\n\n\n\n\n\nTip\n\n\n\nIf your variable is continuous, use a histogram. If your variable is categorical, use a bar chart.\n\n\n\nVisualizing Variation\nWe want to count how many rows fall into each category of the variable cyl, which represents the number of cylinders. Even though cyl is stored as a numeric variable, it behaves more like a categorical variable because the values are discrete (e.g., 4, 6, 8 cylinders). So, for this example, we will be creating a bar chart:\n\nVisualize the distribution of the cyl variable.\n\n\nhide code\nggplot(data = mtcars, aes(x=as.factor(cyl)))+\n  geom_bar(aes(fill=as.factor(cyl)))+\n  labs(x=\"Number of Cylinders\", \n       fill = \"Number of Cylinders\")\n\n\n\n\n\n\n\n\n\nThe barchart above shows us which category has the least amount of rows or the most number of rows. With this visualization, we can see easily that more cars in our data set have 8 cylinders (which was observed when finding the mode of this variable).\n\n\nVisualize the distribution of the mpg variable\nBecause mpg is continuous, we will utilize a histogram.\n\n\nhide code\nggplot(data=mtcars)+\n  geom_histogram(aes(x=mpg), fill=\"lightblue\", binwidth=0.5)\n\n\n\n\n\n\n\n\n\nOur histogram above tells us a few things:\n\nThe distribution for mpg is fairly spread out, with clusters around the 15-25 mpg range.\nThere are less cars that have high miles per gallon (ie &gt; 30).\n\nTo get the numeric values of each bin shown above, we can run the following code:\n\n\nhide code\nmtcars %&gt;% \n  count(cut_width(mpg, 0.5))\n\n\n   cut_width(mpg, 0.5) n\n1          [10.2,10.8] 2\n2          (13.2,13.8] 1\n3          (14.2,14.8] 2\n4          (14.8,15.2] 3\n5          (15.2,15.8] 1\n6          (15.8,16.2] 1\n7          (16.2,16.8] 1\n8          (17.2,17.8] 1\n9          (17.8,18.2] 2\n10         (18.2,18.8] 1\n11         (18.8,19.2] 2\n12         (19.2,19.8] 1\n13         (20.8,21.2] 2\n14         (21.2,21.8] 3\n15         (22.8,23.2] 2\n16         (24.2,24.8] 1\n17         (25.8,26.2] 1\n18         (27.2,27.8] 1\n19         (30.2,30.8] 2\n20         (32.2,32.8] 1\n21         (33.8,34.2] 1\n\n\n\ncut_width() separates your data into groups of your specified width.",
    "crumbs": [
      "Exploratory Data Analysis"
    ]
  },
  {
    "objectID": "07_EDA.html#outliers",
    "href": "07_EDA.html#outliers",
    "title": "Exploratory Data Analysis",
    "section": "Outliers",
    "text": "Outliers\nOutliers can significantly impact model fitting and statistical calculations. They are data points that lie far away from the rest of your observed values. Some measures and models are highly sensitive to these extreme data points so it is always import to conduct exploratory analysis to understand your data (and know the context of your data!).\n\nOutliers are data points that do not seem to fit the pattern.\nSome of these data points can be data entry errors.\nSome can be real observations that suggest new information.\n\n\nVisualizing Outliers\nA boxplot might be one of the easiest ways to visualize outliers within your data set. Additionally, a boxplot provides information about the median, quartiles, and spread of your data. But, outliers are shown as individual dots outside of the whiskers and box.\n\nFind outliers by graphing a boxplot of the hp variable.\n\n\nhide code\nggplot(data=mtcars, aes(x=hp))+\n  geom_boxplot()\n\n\n\n\n\n\n\n\n\nOur above plot shows that most data is centered around the median and is not as wide spread, but it does show one outlier that has a horsepower greater than 300. This plot also shows that most cars in this data set have around 100 - 180 horsepower.\nThis one data point can strongly influence the mean, but not so much of the median.\n\n\nhide code\n# mean with the 300 hp\nmean(mtcars$hp)\n\n\n[1] 146.6875\n\n\nhide code\n# mean without 300 hp\nmean(mtcars$hp[mtcars$hp &lt; 300])\n\n\n[1] 140.6129\n\n\nIt’s also useful to examine outliers within groups. For example, if we extend our boxplot by splitting it according to the am variable (automatic vs. manual transmission), we can see that the results differ between groups.\n\n\nhide code\nggplot(data=mtcars, aes(x=hp))+\n  geom_boxplot(aes(fill=as.factor(am)))\n\n\n\n\n\n\n\n\n\nThe boxplot above compares horsepower (hp) between automatic (am = 0) and manual (am = 1) cars. We can differences in both the spread of the data and outliers. For automatic cars, the distribution of horsepower is wider, but no individual points fall beyond the whiskers. However, the manual group shows two cars with high horsepower, marked as outliers.\n\n\n\n\n\n\n\nImportant\n\n\n\nOutlier detection can depend on how our data is grouped and your question of analysis!\n\n\n\n\nIdentifying outliers\nWe can identify outliers visually by using graphs like boxplots, histograms, etc. However, we can filter our data several ways using different methods:\n\nTukey’s IQR Rule\n\nAn outlier is determined if that value falls below \\(Q1 - 1.5*IQR\\) or above \\(Q3 - 1.5*IQR\\) .\n\n\nhide code\nmtcars &lt;- mtcars %&gt;%\n  mutate(\n    Q1 = quantile(hp, 0.25),      # 25th percentile\n    Q3 = quantile(hp, 0.75),      # 75th percentile\n    IQR = Q3 - Q1,                 # Interquartile range\n    lower_bound = Q1 - 1.5 * IQR,  # lower cutoff\n    upper_bound = Q3 + 1.5 * IQR,  # upper cutoff\n    outlier_iqr = ifelse(hp &lt; lower_bound | hp &gt; upper_bound, 1, 0)\n  )\n\nprint(mtcars %&gt;% filter(outlier_iqr == 1))\n\n\n              mpg cyl disp  hp drat   wt qsec vs am gear carb   Q1  Q3  IQR\nMaserati Bora  15   8  301 335 3.54 3.57 14.6  0  1    5    8 96.5 180 83.5\n              lower_bound upper_bound outlier_iqr\nMaserati Bora      -28.75      305.25           1\n\n\n\n\n\nZ-Score\n\nAnother way is by using z-scores, which measures how many standard deviations a value is away from the mean. This is useful when data is approximately normally distributed.\nBelow, we set the cutoff to be anything more than 2 SD from the mean.\n\n\nhide code\nmtcars &lt;- mtcars %&gt;%\n  mutate(zscore_hp = as.numeric(scale(hp)),\n         outlier_zscore = ifelse(abs(zscore_hp) &gt; 2, 1, 0))\n\nprint(mtcars %&gt;% filter(outlier_zscore == 1))\n\n\n              mpg cyl disp  hp drat   wt qsec vs am gear carb   Q1  Q3  IQR\nMaserati Bora  15   8  301 335 3.54 3.57 14.6  0  1    5    8 96.5 180 83.5\n              lower_bound upper_bound outlier_iqr zscore_hp outlier_zscore\nMaserati Bora      -28.75      305.25           1  2.746567              1\n\n\n\n\n\nPercentiles\n\nOutliers can also be identified through percentiles which splits the data into 100 equal parts.\nBelow we set the cutoff to be anything more than the 95th percentile value.\n\n\nhide code\nmtcars &lt;- mtcars %&gt;%\n  mutate(\n    outlier_pct = ifelse(hp &gt; quantile(hp, 0.95), 1, 0)\n  )\n\nprint(mtcars %&gt;% filter(outlier_pct == 1))\n\n\n                mpg cyl disp  hp drat   wt qsec vs am gear carb   Q1  Q3  IQR\nFord Pantera L 15.8   8  351 264 4.22 3.17 14.5  0  1    5    4 96.5 180 83.5\nMaserati Bora  15.0   8  301 335 3.54 3.57 14.6  0  1    5    8 96.5 180 83.5\n               lower_bound upper_bound outlier_iqr zscore_hp outlier_zscore\nFord Pantera L      -28.75      305.25           0  1.711021              0\nMaserati Bora       -28.75      305.25           1  2.746567              1\n               outlier_pct\nFord Pantera L           1\nMaserati Bora            1",
    "crumbs": [
      "Exploratory Data Analysis"
    ]
  },
  {
    "objectID": "07_EDA.html#handling-outliers",
    "href": "07_EDA.html#handling-outliers",
    "title": "Exploratory Data Analysis",
    "section": "Handling Outliers",
    "text": "Handling Outliers\n\nUnderstand the Cause:\n\nNatural Variability: Legitimate data variation\nData Entry Errors: Mistakes in data collection or entry.\nInstrument/Process Error: Issues with data collection methods.\n\nDecide on an Approach:\n\nKeep Them: If they reflect true variation.\nTransform Data: Reduce their impact.\nCap/Floor Values: Limit extreme outliers.\nRemove Them: If they’re errors or irrelevant—document decisions.\nUse Robust Models: Opt for models less sensitive to outliers.\n\nALWAYS DOCUMENT!",
    "crumbs": [
      "Exploratory Data Analysis"
    ]
  },
  {
    "objectID": "07_EDA.html#covariance-and-correlation",
    "href": "07_EDA.html#covariance-and-correlation",
    "title": "Exploratory Data Analysis",
    "section": "Covariance and Correlation",
    "text": "Covariance and Correlation\nCovariance expresses how two numeric variables change together, whether it be positive or negative. (Covariance is sensitive and influenced by the units and scales of our variables.)\n\na positive result indicates a positive linear relationship - as x increases, y increases\na negative result indicates a negative linear relationship - as x decreases, y decreases\n\nCorrelation helps interpret covariance further by assessing both the strength and direction. The Pearson’s correlation coefficient, \\(\\rho_{xy}\\), is the most commonly used measure, where \\[-1 \\leq \\rho_{xy} \\leq 1\\]\n\n\\(\\rho_{xy} = -1\\) indicates a near perfect negative linear relationship\n\\(\\rho_{xy} = 1\\) indicates a near perfect positive linear relationship\nHowever, the relationship gets weaker the closer the coefficient is to 0.\n\nLet’s investigate more into the mtcars dataset and see if there is a relationship between hp, the gross horsepower of a car, and qsec, the shortest time taken to travel a quarter-mile distance.\n\nWhat is the relationship between hp and qsec?\nFirst, we will visualize the relationship by plotting a scatterplot:\n\n\nhide code\nscatter &lt;- ggplot(data = mtcars,\n                  aes(x = hp, \n                      y = qsec))+\n           geom_point()\nprint(scatter)\n\n\n\n\n\n\n\n\n\nWe can observe a negative relationship from the scatterplot, which means that cars that take a shorter amount of time to travel a quarter-mile tend to have more horsepower. (as x increases, y decreases).\nWhen we compute the covariance and correlation for these two variables, we get:\n\n\nhide code\ncov(mtcars$hp, mtcars$qsec)\n\n\n[1] -86.77008\n\n\nhide code\ncor(mtcars$hp, mtcars$qsec)\n\n\n[1] -0.7082234\n\n\nThe negative value from our covariance determines a negative relationship. However, the strength of this relationship is dependent on the units of our variable in question, so this value -86 is not easily interpretable.\nThe correlation value of ~ -0.71 standardizes the covariance by proportioning it between -1 and 1. This negative 0.71 value says that there is a slightly strong negative correlation.\n\nHow does the above correlation change when we remove the outliers we identified in the hp (horsepower) variable?\n\n\nhide code\n# correlation when we remove outliers identified by Tukey's Rule\ncor(mtcars$hp[mtcars$outlier_iqr != 1], \n    mtcars$qsec[mtcars$outlier_iqr != 1])\n\n\n[1] -0.6638874\n\n\nhide code\n# correlation when we remove outliers &gt; 95th percentile\ncor(mtcars$hp[mtcars$outlier_pct != 1], \n    mtcars$qsec[mtcars$outlier_pct != 1])\n\n\n[1] -0.6082645\n\n\nWe see that when we remove outliers the strength of the relationship is not as strong when we include cars that have higher horsepower.\n\n\n\n\n\n\nTip\n\n\n\nWhen would be the best time to remove or keep all data points?\nIf the goal is to focus on cars that are more “typical” in terms of horsepower, then removing the outliers can make the analysis more representative of that group. But, if the goal is to understand all cars in the dataset, then it is best to leave those data points in.\n\n\n\nCorrelation within group\nLet’s quickly look at another example of correlation using data from the iris data set. This data set contains measurements of sepal width/length and petal length/width of 50 different flowers from 3 different species of iris.\n\nWhat is the correlation between petal length and petal width?\n\n\nhide code\ncor(iris$Petal.Length, iris$Petal.Width)\n\n\n[1] 0.9628654\n\n\n\n\nhide code\nggplot(data = iris, aes(x=Petal.Length, y = Petal.Width))+\n  geom_point()\n\n\n\n\n\n\n\n\n\nOur value of 0.96 suggests that petal length and petal width have a strong, positive association, ie we can expect a larger petal length if petal width is large as well. We can kinda see this pattern when we look at the scatter plot above.\nBUT, how does the correlation change when we observe the relationship by species?\n\n\nhide code\ncor_group &lt;- iris %&gt;%\n    group_by(Species) %&gt;%\n    summarize(correlation = cor(Petal.Length, Petal.Width))\n\nprint(cor_group)\n\n\n# A tibble: 3 × 2\n  Species    correlation\n  &lt;fct&gt;            &lt;dbl&gt;\n1 setosa           0.332\n2 versicolor       0.787\n3 virginica        0.322\n\n\nThe correlation is not as strong for the setosa and the virginica species. At times, grouping makes a large difference. If we look at the overall correlation, we might assume that this relationship holds for all iris species, which as shown may not be the case.\n\n\nhide code\nggplot(data = iris, aes(x=Petal.Length, y=Petal.Width, color=Species))+\n  geom_point()+facet_wrap(~Species)\n\n\n\n\n\n\n\n\n\n\n\n\nCreating a correlation matrix\nIf you would like to compute the correlation of each numeric variable to eachother for the whole mtcars dataset:\n\n\nhide code\nmtcars &lt;- mtcars %&gt;% select(mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb)\ncor_matrix &lt;- round(cor(mtcars),2)\ncor_matrix\n\n\n       mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\nmpg   1.00 -0.85 -0.85 -0.78  0.68 -0.87  0.42  0.66  0.60  0.48 -0.55\ncyl  -0.85  1.00  0.90  0.83 -0.70  0.78 -0.59 -0.81 -0.52 -0.49  0.53\ndisp -0.85  0.90  1.00  0.79 -0.71  0.89 -0.43 -0.71 -0.59 -0.56  0.39\nhp   -0.78  0.83  0.79  1.00 -0.45  0.66 -0.71 -0.72 -0.24 -0.13  0.75\ndrat  0.68 -0.70 -0.71 -0.45  1.00 -0.71  0.09  0.44  0.71  0.70 -0.09\nwt   -0.87  0.78  0.89  0.66 -0.71  1.00 -0.17 -0.55 -0.69 -0.58  0.43\nqsec  0.42 -0.59 -0.43 -0.71  0.09 -0.17  1.00  0.74 -0.23 -0.21 -0.66\nvs    0.66 -0.81 -0.71 -0.72  0.44 -0.55  0.74  1.00  0.17  0.21 -0.57\nam    0.60 -0.52 -0.59 -0.24  0.71 -0.69 -0.23  0.17  1.00  0.79  0.06\ngear  0.48 -0.49 -0.56 -0.13  0.70 -0.58 -0.21  0.21  0.79  1.00  0.27\ncarb -0.55  0.53  0.39  0.75 -0.09  0.43 -0.66 -0.57  0.06  0.27  1.00\n\n\nIn the above code, we provide the cor() function the whole mtcars data set when mtcars ONLY consists of numeric variables (note, we only selected the numeric columns - if there are other columns, such as character columns, this would error out). The output provides us with a numeric representation of our correlation matrix.\n\nVisualizing correlation matrix using ggplot2\n\n\nhide code\n# set correlation matrix to a data frame first\ncor_matrix &lt;- as.data.frame(cor_matrix)\n\n# create a new column that is the row names of our inital matrix\ncor_matrix$var1 &lt;- row.names(cor_matrix)\nhead(cor_matrix, 3)\n\n\n       mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb var1\nmpg   1.00 -0.85 -0.85 -0.78  0.68 -0.87  0.42  0.66  0.60  0.48 -0.55  mpg\ncyl  -0.85  1.00  0.90  0.83 -0.70  0.78 -0.59 -0.81 -0.52 -0.49  0.53  cyl\ndisp -0.85  0.90  1.00  0.79 -0.71  0.89 -0.43 -0.71 -0.59 -0.56  0.39 disp\n\n\nhide code\n# pivot the data set from wide to long\ncor_matrix &lt;- pivot_longer(cor_matrix, \n                           cols = colnames(mtcars), \n                           names_to = \"var2\")\n\n# set the order we want our variables to appear\ncor_matrix$var1 &lt;- factor(cor_matrix$var1, \n                          levels = rev(colnames(mtcars)))\ncor_matrix$var2 &lt;- factor(cor_matrix$var2, \n                          levels = colnames(mtcars))\n\n\nAfter the above data manipulation, we can create a heatmap using ggplot to visualize our matrix.\n\n\nhide code\nheatmap &lt;- ggplot(cor_matrix, aes(x = var1, \n                                  y = var2, \n                                  fill = value))+\n  geom_tile()+\n  scale_fill_gradient2(\n    low = \"darkblue\",  \n    mid = \"white\",     \n    high = \"red\",      \n    midpoint = 0,      \n    limits = c(-1, 1))  \n\nprint(heatmap)\n\n\n\n\n\n\n\n\n\n\n\nVisualizing using the corrplot package\nA simpler way to visualize this correlation matrix is by using corrplot.\n\n\nhide code\nlibrary(corrplot)\n\n\nWarning: package 'corrplot' was built under R version 4.3.3\n\n\ncorrplot 0.94 loaded\n\n\nhide code\ncor_mat &lt;- cor(mtcars)\ncorrplot(cor_mat)\n\n\n\n\n\n\n\n\n\nIn the above code, we provide the function corrplot() with the numerically computed correlation matrix.\n\nChoosing to use ggplot vs corrplot is your personal preference. ggplot may provide additional customization for complex cases.",
    "crumbs": [
      "Exploratory Data Analysis"
    ]
  },
  {
    "objectID": "07_EDA.html#data-transformation",
    "href": "07_EDA.html#data-transformation",
    "title": "Exploratory Data Analysis",
    "section": "Data Transformation",
    "text": "Data Transformation\nIn some cases, we may need to transform our data. By transforming, I mean by taking the log or the square root to help patterns be easier to see and analyze or to scale the data.\nWhy should we transform?\n\nreduce skewness (or make more normal?)\nstablize the spread\nlinearize the non-linear\nreduce the impact of outliers\n\nTo discuss data transformation in more detail, we will look at the diamonds data set which comes with ggplot2. This data set contains prices for over 50,000 round cut diamonds. You can read more about it when pulling up the documentation (?diamonds).\nLet’s visualize the variable price to see how the different prices of each diamond in the data set ranges from.\n\n\nhide code\nhist(diamonds$price, col = \"blue\")\n\n\n\n\n\n\n\n\n\nOur above scatter plot shows that our data is right-skewed, we have lots of diamonds that range from $0-$5000, and very few diamonds that are above the $15,000 price range.\nLet’s look at the distribution if we take the log of the price variable.\n\n\nhide code\nhist(log(diamonds$price), col = \"blue\")\n\n\n\n\n\n\n\n\n\nAfter we log transform the price variable, we see the the distribution looks more balanced and symmetric from before. We see that our extreme values of price are now compressed, which may indicate that those large values will be less influential.\nLet’s dive more into the price of diamonds based on the carat size (the carat variable).\n\n\nhide code\nggplot(diamonds, aes(x = carat, y = price)) +\n  geom_point() +\n  labs(title = \"Carat vs Price (Raw)\")\n\n\n\n\n\n\n\n\n\nIn the above scatter plot, we see\n\nthere are MANY data points which make it hard to fully understand the pattern or relationship between the two variables\nthe overall trend seems to be positive, when carat size increases, price seems to increase as well, but the plot is curving up.\nsmall diamonds are clustered at the bottom, and for larger diamonds, there is larger variation/more spread.\nnote, there is an extreme value around ~5 with a price range &gt; 15,000\n\n\n\nhide code\nggplot(diamonds, aes(x = log(carat), y = log(price))) +\n  geom_point() +\n  labs(title = \"Carat vs Price (Log)\")\n\n\n\n\n\n\n\n\n\nWhen we plot the relationship with their log values, we see a more linear relationship with reduced variation.\n\nImpact on Models\nWhen we look at correlation, we are measuring the linear association between two different variables.\n\n\nhide code\ncor(diamonds$carat, diamonds$price)\n\n\n[1] 0.9215913\n\n\n\n\nhide code\ncor(log(diamonds$carat), log(diamonds$price))\n\n\n[1] 0.9659137\n\n\nAlthough it is not a big change in correlation, the value between the log variables is stronger, indicating that our diamonds with extreme prices have less of an effect on the correlation. As we see in the scatter plots above, the graph shows an almost-perfect linear relationship.\n\n\n\n\n\n\nTip\n\n\n\nTransforming to log will help when the relationship is curved or skewed and most especially when the data is being driven by outliers.\n\n\nWhen we perform a simple linear regression model:\n\n\nhide code\nsummary(lm(price ~ carat), data = diamonds)\n\n\n\n\nModel Formula: price ~ carat \n\nR-squared: 0.849 \nAdj R-squared: 0.849 \nResidual Std Error: 1548.562 \n\n             Estimate Std. Error   t value Pr(&gt;|t|)\n(Intercept) -2256.361   13.05535 -172.8304        0\ncarat        7756.426   14.06658  551.4081        0\n\n\n\n\nhide code\nsummary(lm(log(price) ~ log(carat)), data = diamonds)\n\n\n\n\nModel Formula: log(price) ~ log(carat) \n\nR-squared: 0.933 \nAdj R-squared: 0.933 \nResidual Std Error: 0.263 \n\n            Estimate  Std. Error   t value Pr(&gt;|t|)\n(Intercept) 8.448661 0.001364691 6190.8959        0\nlog(carat)  1.675817 0.001933806  866.5901        0\n\n\nWhen we model price ~ carat without the transformation, the slope tells us that for every extra carat, the diamond’s price increases by about $7,756. The model explains about 85% (shown by the R^2 value) of the variation in price, but it has large residuals. The model predictions are off by about $1,500 on average.\nOur model when we do transform the data, the log-log model (log(price) ~ log(carat)), fits the data much better. The slope means that a 1% increase in carat size is associated with about a 1.68% increase in price. The model fit is stronger (R² = 0.933 vs 0.849) and the residuals are smaller. Instead of predictions being off by about $1,500, the log model’s residual standard error is only 0.263 (in log units). When we back-transform that, it means the model’s predictions are usually within about give or take 26% of the actual price.",
    "crumbs": [
      "Exploratory Data Analysis"
    ]
  }
]